{
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "\n",
                "* :: Duplication operations in which the result returned is a duplication of references\n",
                "\n",
                "\n",
                "[Web site references for relationship descriptions] (https://www.cnblogs.com/dhm520/p/8423392.html)\n",
                "\n",
                "* **IS-A**: is-a, representing an **inheritance** relationship. If A is-a B, then B is the parent class of A. A class completely contains all the attributes and behavior of another class.\n",
                "  For example, a PC is a computer and a workstation is a computer; PCs and workstations are two different types of computers, but both inherit the common characteristics of computers. is-a (English: subsumption, inclusion) refers to the inclusive relationship embodied between abstractions (such as classes or types).\n",
                "\n",
                "* **HAS-A**: has a, representing a **subordinate** relationship. If A has a B, then B is a component of A. Objects of the same kind can be distinguished by the different values of their attributes.\n",
                "  For example, one PC's operating system is Windows and another PC's operating system is Linux. operating system is a member variable of the PC, and different PC objects can be distinguished based on different values of this member variable.\n",
                "\n",
                "* **LIKE-A**: like one, representing a **combination** relationship. If A like a B, then B is an interface to A. The new type has the interface of the old type, but also contains other functions, so they cannot be said to be identical.\n",
                "  For example, a cell phone can be said to be a microcomputer, but the phone dialing numbers is not a computer with the behavior, so the phone inherits the characteristics of the computer, and at the same time need to realize the communication function, which needs to be used as a separate interface, rather than the behavior of the computer."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1.3. what is computer science?"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Computer science is \n",
                "* the study of problems, problem-solving and the solutions that come out of the problem-solving process.\n",
                "* thought as the study of solutions, or rather, the study of solutions to problemsas well as the study of problems with no solutions.\n",
                "* the study of problems that are and that are not computable, the study of existence and the nonexistence of algorithms.\n",
                "* the study of abstraction. Abstraction allows us to view the problem and solution in such a way as to separate the so-called logical and physical perspectives."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Algorithm is \n",
                "* a step-by-step list of instructions for solving any instance of the problem that might arise.\n",
                "* **finite** processes that if followed will solve the problem.\n",
                "* solution.\n",
                "* considered independent from machine.\n",
                "* describes the solution to a problem in terms of the data needed to represent the problem instance and the set of steps necessary to produce the intended result.(1.3.1.)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Computable \n",
                "* describing problems and solutions.\n",
                "* if an algorithm exists for solving it."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Someone could view computers from logical or user perspective, and functions are sometimes also reffered to as the interface.(port)The user of the abstraction, sometimes also called client, does not need to know the details as long as the user is aware of the way the interface works. \n",
                "\n",
                "While computer scientists, programmers, technology support staff, and system administrators must know the details of how operating systems work, how network protocols are configured, and how to code various scripts that control function. They must be able to control the low-level details that a user simply assumes."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The interface is the way we as users communicate with the underlying complexities of the implementation. Consider the python math module as an example of procedural abstraction, who could be referred to as a black box view of a process. The interface could be simply described: \n",
                "* the name of function\n",
                "* what is needed(parameters)\n",
                "* what will be returned\n",
                "  \n",
                "the details are hidden inside black box."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 1.3.1. What is programming?\n",
                "Programming is the process of taking an algorithm and encoding it into anotion,a programming language,so that it can be executed by a computer.\n",
                "\n",
                "Programming languages must provide a notational way to represent both the process and the data. To this end, provide \n",
                "* control constructs(sequential processing, selection for decision-making,iteration for repetitive control) \n",
                "* data types, who give all these data items represented as strings of binary digits meaning.\n",
                "\n",
                "These low-level, build-in data types (sometimes called **_the primitive data types_**) provide the building blocks for algorithm development."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 1.3.2. Why study Data Structures and Absreact Data Type?\n",
                "\n",
                "An abstract data type, sometimes abbreviated ADT, is a logical description of how we view the data and the operations that are allowed without regard to how they will be implemented.\n",
                "\n",
                "$\\implies$ we are concerned only with what the data is representing and not with how it will eventually be constructed.\n",
                "\n",
                "\n",
                "Data abstraction : using encapsulation for information hiding.\n",
                "\n",
                "An abstract data type,in short, ADT, can be used as the shell that user interacts with, which is a logical description of how we view the data and the operations that are allowed without regard to how they will be implemented.\n",
                "\n",
                "While **the implementation of an ADT,often referred to as a data structure**,will require that we provide a physical view of the data, using some collection of programming constructs, and primitive data types.\n",
                "\n",
                "With this inplementation-independent view of the data,users can remain focused on the problem-solving process,getting rid of details of the implementation(1.3.)."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 1.3.3. Why study algorithms?\n",
                "By considering a number of different algorithms, we can begin to develop pattern recognition so that the next time a similar problem arises, we are better able to solve it.\n",
                "\n",
                "As we study algorithms, we can learn analysis techniques that allow us to compare and contrast solutions solely on their own characteristics, not the characteristics of the program or computer used to implement them."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1.4. Review of basic python"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 1.4.1. Getting started with data\n",
                "* Python supports the object-oriented, which means that Python condiders data to be the focal point of the problem-solving process. We define a **class** to describe what the data look like (the state) and what the data can do (the behavior).\n",
                "* Classes are analogous to abstract data types because a user of a class only sees the state and the behavior of a data item.\n",
                "* Data items are called **objects** in the object-oriented paradigm.\n",
                "* An object is an instance of a class."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 1.4.1.1. Built-in Atomic data types\n",
                "**numeric classes**\n",
                "\n",
                "* Python has 2 main built-in numeric classes, interger and floating point data types, called int and float.\n",
                "* The standard arithmetic operations ```+```, ```-```, ```*```, ```/```, and ```**``` (exponentiation), can be used with parentheses, forcing the order of operations away from normal operator precedence.\n",
                "* Other very useful operations are the remainder (modulo) operator, ```%```, and integer division, ```//```.\n",
                "* When 2 intergers are divided, the result is a floating point.\n",
                "* The integer division operator ```//``` returns the integer portion of the quotient by truncating any fractional part."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "6/3"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "3//6"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "**bool class**\n",
                "* The boolean data type is implemented as the Python bool class\n",
                "* For repesenting truth values.\n",
                "* The possible state values for a boolean object are **True** and **False**\n",
                "* The standard boolean operators are ```and```, ```or```, ```not```.\n",
                "* Boolean objects are also used as results for comparison operators such as equality ```==``` and greater than```>```.\n",
                "* In addition, relational operators and logical operators can be combined together to form complex logical questions."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "**Identifiers / Names**\n",
                "* Identifiers are used in programming languages as names. \n",
                "* In python, identifiers started with a letter or an underscore ```_```, and **case-sensitive**.\n",
                "* Assignment statements ```=``` provide a way to associate a name with a value.\n",
                "* The python variable is created when a name is used for the first time on the left-hand side of an assignment.\n",
                "* A Python variable will hold a **_reference_** to a piece of data, not the data itself.\n",
                "* In general, the right-hand side of the assignment statement is evaluated, and a reference to the resulting data object is \"assigned\" to the name on the left-hand side.\n",
                "* The same variable can refer to many different types of data.\n",
                "\n",
                "key point :\n",
                ">The assignment statement changes the reference being held by the variable, which is a **dynamic** characteristic of Python.\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "|name|assignment statement|value|\n",
                "|:--:|:--:|:--:|\n",
                "|The python variable is created when a name is used for the first time|$\\xLeftarrow {a\\ reference}$|evaluated|"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "#### 1.4.1.2. Built-in Collection Data types \n",
                "\n",
                "|method|ordered|mutable|\n",
                "|:---:|:---:|:---:|\n",
                "|list|Sequentially|Y|\n",
                "|string|Sequentially|N|\n",
                "|tuple|Sequentially|N|\n",
                "|set|N|Y|\n",
                "|dictionary|Insertion(from Python 3.7+)|Y|"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "$\\Longrightarrow$ \n",
                "\n",
                "**operations on any sequence in python**\n",
                "|Name|Notion|\n",
                "|----|----|\n",
                "|indexing|[ ]|\n",
                "|concatenation|\\+|\n",
                "|repetition|\\*|\n",
                "|membership|in|\n",
                "|length|len|\n",
                "|slicing|[ : ]|\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "**List**\n",
                "* is an ordered collection of zero or more **references**.\n",
                "* is heterogeneous, meaning that the data objects need not all be from the same class and the collection can be assigned to a variable.\n",
                "\n",
                "tips:\n",
                "> When Python evaluates a list, the list itself is returned. To remember the returned one for later processing, its reference needs to be assigned to a variable."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 32,
            "metadata": {},
            "outputs": [],
            "source": [
                "# List is written as comma-delimited values enclosed in square brackets.\n",
                "l1 = []\n",
                "l2 = list()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Operations for **list**\n",
                "\n",
                "* The slice operation,take myList[1:3] as example,returns a list of items starting with 2nd item,and not including the item indexed by 3"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Lists could be quickly initialized by repetition.\n",
                "myList = [0]*6\n",
                "myList"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# The result is a repetition of references \n",
                "myList = [1,2,3,4]\n",
                "A = [myList] * 3\n",
                "print(A)\n",
                "print('**********************')\n",
                "myList[2] = 45\n",
                "print(A)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "**Methods provided by list in python**\n",
                "| Method | List Changed | Reference Changed | Returned |\n",
                "|-----|:-----------:|:----------:|:--------:|\n",
                "| alist.sort() | Y | N | None |\n",
                "| sorted(alist) | N | N | Sorted List |\n",
                "| alist.reverse() | Y | N | None |\n",
                "| reversed(alist) | N | N | Iterator |\n",
                "| alist.pop() | Y | N | Last Item |\n",
                "| alist.pop(i) | Y | N | Item at ```i``` |\n",
                "| del alist[i] | Y | N | None |\n",
                "| alist.insert(i,item) | Y | N | None |\n",
                "| alist.append(item) | Y | N | None |\n",
                "| alist.index(item) | N | N | Index ```i``` |\n",
                "| alist.count(item) | N | N | Integer |\n",
                "| alist.remove(item) | Y | N | None |\n",
                "|alist.clear()|Y|N|None|\n",
                "|alist.extend(blist)|alist|N|None|\n",
                "|alist + blist|N|N|New List|\n",
                "\n",
                "* It would be better to name the new list returned by ```sorted``` or```reversed```.\n",
                "* There is another reference for the result of ```alist.extend(blist)```, while the alist could be used as the result of extention.\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "help(id)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# Return the identity of an object."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.sort())\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# Return the identity of an object."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(sorted(alist))\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {
                "scrolled": true
            },
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.reverse())#through print None,the list still changed.\n",
                "print(alist)\n",
                "print(id(alist))#id did not changed"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(reversed(alist))#it creates something new.\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#hexadecimal\n",
                "hex_add = f\"0x{id(alist):016X}\"# Automatically handles the uppercase conversion with X format specifier\n",
                "print(hex_add)\n",
                "#Python reversed() method returns an iterator that accesses the given sequence in the reverse order.\n",
                "blist = reversed(alist)\n",
                "print(blist)#It turns out to be a NEW reference."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(list(blist))# the returned item changed\n",
                "print(id(list(blist)))#id changed\n",
                "print(f\"0x{id(list(blist)):016X}\")# the returned Iterator also has different id from the list you make"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "$\\Longrightarrow$ So you should name the list returned by 'reversed'."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.pop())\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.pop(3))\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "del alist[2]"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.insert(6,'badApple'))\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.append(7))\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.index(3))\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.count(3))\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = [1,2,3,4,1,9,7,5,3]\n",
                "id(alist)# renew"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.remove(3))\n",
                "print(alist)#remove the first 3\n",
                "print(id(alist))#not changed"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist.clear())\n",
                "print(alist)\n",
                "print(id(alist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = ['apple', 'banana', 'cherry']\n",
                "blist = (1, 4, 5, 9)#tuple\n",
                "\n",
                "print(id(alist))\n",
                "print(id(blist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#clist = alist.extend(blist)#there must be another id\n",
                "print(alist.extend(blist))\n",
                "print(id(alist.extend(blist)))#exrenf blist 2 times"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist)\n",
                "print(id(alist))\n",
                "print(blist)\n",
                "print(id(blist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = ['apple', 'banana', 'cherry']\n",
                "blist = [1, 4, 5, 9]\n",
                "\n",
                "print(id(alist))\n",
                "print(id(blist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(alist + blist)\n",
                "print(alist)\n",
                "print(id(alist))\n",
                "print(blist)\n",
                "print(id(blist))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "alist = ['apple', 'banana', 'cherry']\n",
                "blist = [1, 4, 5, 9]\n",
                "\n",
                "print(id(alist))\n",
                "print(id(blist))\n",
                "print(id(alist + blist))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The dot notion is asking for an object to invoke a method. Even if it is integer."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 1,
            "metadata": {},
            "outputs": [
                {
                    "data": {
                        "text/plain": [
                            "86"
                        ]
                    },
                    "execution_count": 1,
                    "metadata": {},
                    "output_type": "execute_result"
                }
            ],
            "source": [
                "(54).__add__(32)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The another common python function conjunction with ```list``` is the ```range```, who produces a range object that represents a sequence of values."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 6,
            "metadata": {},
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "range(0, 10)\n",
                        "[5, 6, 7, 8, 9]\n",
                        "[1, 3, 5, 7, 9]\n"
                    ]
                }
            ],
            "source": [
                "print(range(0,10))\n",
                "print(list(range(5,10)))\n",
                "print(list(range(1,10,2)))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "**String**\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "MyName = \"David\"\n",
                "MyName[0] = 'x'"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1.4. tuple [unalterable]\n",
                "Tuples, like sequences, allow any of the operations previously described"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "t1 = ()\n",
                "t2 = tuple()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Tuples VS Lists\n",
                "* :: Lists or tuples are heterogeneous\n",
                "* :: Subscripts are continuous from zero\n",
                "* :: Addition and multiplication\n",
                "* len()\n",
                "* Index alis[n] or atuple[n]. The result obtained can be used as a name on the left side of the assignment statement [tuples cannot be reassigned], or of course on the right side.\n",
                "* 切片alist[start:end:step]；atuple[star:end:step]]\n",
                "* in\n",
                "* index\n",
                "* count\n",
                "* sum\n",
                "* min/max\n",
                "\n",
                "Different:\n",
                "* :: Tuples are not modifiable, lists are modifiable\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {
                "scrolled": true
            },
            "outputs": [],
            "source": [
                "MyTuple = (2,True,4.96)\n",
                "MyTuple[1] = False"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Unordered collection\n",
                "* set\n",
                "* dictionary"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# 2. Unordered sets"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2.1. collection [unchangeable]\n",
                "\n",
                "or set, is an unordered collection of zero or more unmodifiable Python data objects that does not allow duplicate elements and is heterogeneous\n",
                "\n",
                "But it also supports some of the previous operations\n",
                "\n",
                "|method name|usage|\n",
                "|:--:|:--:|\n",
                "|query element|in|\n",
                "|length|len|\n",
                "|并集|aset \\| otherset|\n",
                "|交集|aset&otherset|\n",
                "|差集|aset - otherset|\n",
                "|whether subset|aset <= otherset|\n",
                "\n",
                "The special operations of set are\n",
                "\n",
                "|method name|usage|\n",
                "|:--:|:--:|\n",
                "|并集|aset.union(otherset)|\n",
                "|交集|aset.intersection(otherset)|\n",
                "|差集|aset.difference(otherset)|\n",
                "|是否子集|aset.issubset(otherset)|\n",
                "|element add|aset.add(item)|\n",
                "|elementRemove|aset.remove(item)|\n",
                "|randomize deletion|aset.pop()|\n",
                "|elements all clear|aset.clear()|"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2.2. Dictionary [subject to change]"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: Dictionaries are labeled data. The set of pairs of label key and data value is called a dictionary\n",
                "* Indexes data by tags or keywords, as opposed to lists or tuples which are indexed by consecutive integers.\n",
                "* :: Adding a new value is also done with the key\n",
                "* :: Is unorganized. The position of the key is determined by the hash\n",
                "* :: Is of variable type and can be added deleted or replaced"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "student = {}\n",
                "student = dict()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "phoneext = {'david':1410,\"brad\":1137}\n",
                "phoneext"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "phoneext.keys()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "phoneext.values()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "list(phoneext.values())"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "phoneext.items()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "list(phoneext.items())"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "phoneext.get(\"kent\", \"no entry\")# If not, return no entry"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "phoneext"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "phoneext['david']"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "phoneext.update(friends = [\"a\",\"b\"])\n",
                "phoneext"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Data item (item)\n",
                "* :: Include key and value, concatenated with a colon\n",
                "* value has no order and can be of any type, even a dictionary\n",
                "* [key can only be immutable type]: numeric value, string and tuple. For example, tuples are used as coordinates, index elements."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Dictionary updating program\n",
                "\n",
                "* :: Merge dictionaries: overwrite the same key, add a key where none exists\n",
                "\n",
                "* :: Growing dictionaries:\n",
                "\n",
                "1) ```dic[key]=value```\n",
                "\n",
                "2) ```dic.update(friends = [\"a\",\"b\"])```\n",
                "\n",
                "* :: Dictionary reduction.\n",
                "  \n",
                "1) ```del student['age']```\n",
                "\n",
                "2) ```student.pop('course')```\n",
                "\n",
                "3) ```student.popitem()``` [randomly removes and returns a data item, good for traversing dictionaries]\n",
                "\n",
                "4) Clear the dictionary clear\n",
                "\n",
                "* :: Dictionary size len\n",
                "\n",
                "* :: Tag indexing\n",
                "\n",
                "1)```dict[key]```\n",
                "\n",
                "2)```student.get(key)```\n",
                "\n",
                "* The keys function returns all the tags in the dictionary.\n",
                "* :: The values function returns all the data values in the dictionary\n",
                "* :: items returns a binary set of data items as key-value pairs\n",
                "* :: Determining whether a label exists: the in operation\n",
                "* :: Determining the existence of values: the in + values operation"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "student.update(friends = [\"a\", \"b\"])# No double quotes!\n",
                "#student.pop('friends')\n",
                "print(student)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2.3. Inputs and outputs\n",
                "Format the string as follows"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(\"Hello\",\"World\",sep = \"***\")\n",
                "print('Hello','World',end = '***')"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "aName = 'Lily'\n",
                "age = 27\n",
                "print(\"%s is %d years old.\"%(aName,age))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Type declarations available for formatting strings\n",
                "\n",
                "|Characters|Output Format|\n",
                "|:--:|:--|\n",
                "|d,i| integer|\n",
                "|u|unsigned integers|\n",
                "|f|m.dddd format floating point numbers|\n",
                "|e|m.dddde+/-xx format floating point number|\n",
                "|E|m.ddddE+/-xx format floating point number|\n",
                "|g| Use %e for indices less than -4 or greater than 5, otherwise %f|.\n",
                "|c|single character|\n",
                "|s| string or any python object that can be converted to a string by str|.\n",
                "|%|Insert a constant symbol|"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "price = 24\n",
                "item = \"banana\"\n",
                "\n",
                "print(\"The %+10s costs %5.2f cents.\"%(item,price))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "itemdict = {\"item\":\"banana\",\"cost\":24}\n",
                "print(\"The %(item)s costs %(cost)7.1f cents.\"%itemdict)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2.4. control structure\n",
                "\n",
                "The two most important control structures in the algorithm are:\n",
                "\n",
                "***Iteration**\n",
                "\n",
                "**Branch**\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 2.4.1. Iterative structure"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Use while\n",
                "counter = 1\n",
                "while counter <= 5:\n",
                "    print(\"Hello World!\")\n",
                "    counter += 1\n",
                "    print(counter)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Use for\n",
                "for item in list(range(1,10,2)):\n",
                "    print(item)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "wordlist = ['cat','dog','rabbit']\n",
                "letterlist = list()\n",
                "for aword in wordlist:\n",
                "    for aletter in aword:\n",
                "        letterlist.append(aletter)\n",
                "\n",
                "print(letterlist)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 2.4.2. Branching statements\n",
                "Nesting is supported, using the if end or elif keywords. However, when using elif, the final else is still needed to handle the case where all the branching conditions are not satisfied."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "score = 30\n",
                "if score >= 90:\n",
                "    print(\"A\")\n",
                "elif score >= 80:\n",
                "    print(\"B\")\n",
                "elif score >= 70:\n",
                "    print(\"C\")\n",
                "elif score >= 60:\n",
                "    print(\"D\")\n",
                "else:\n",
                "    print(\"F\")\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 2.4.3. List resolving equations\n",
                "\n",
                "Creating lists via iterative or branching structures"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#Complicated version\n",
                "sqlist = []\n",
                "for x in range(1,11):\n",
                "    sqlist.append(x*x)\n",
                "print(sqlist)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#Simple version\n",
                "sqlist = [x*x for x in range(1,11)]\n",
                "print(sqlist)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#Advanced\n",
                "sqlist = [x*x for x in range(1,11) if x%2 == 0]\n",
                "print(sqlist)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# 3. Exception handling\n",
                "The following types of errors may be encountered while programming:\n",
                "\n",
                "* :: Syntax error. Compiler error.\n",
                "\n",
                "* :: Logic error. Can be executed but returns an incorrect result.\n",
                "\n",
                "Some logic errors can cause runtime errors that can cause a program to terminate. These errors are often referred to as \"exceptions\". Programmers can create exceptions themselves if they detect a problem with program execution."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Use try statements to handle thrown exceptions\n",
                "import math\n",
                "anumber = int(input(\"please enter an integer\"))\n",
                "try:\n",
                "    print(math.sqrt(anumber))\n",
                "except:\n",
                "    print(\"Bad Value for square root.\")\n",
                "    print(\"Using absolute value instead.\")\n",
                "    print(math.sqrt(abs(anumber)))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#Triggering runtime exceptions with raise statements\n",
                "import math\n",
                "anumber = 23\n",
                "if anumber < 0:\n",
                "    raise RuntimeError(\"you can't use a negative number.\")\n",
                "else:\n",
                "    print(math.sqrt(anumber))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# 4. Defining functions\n",
                "After defining a function, the details of the computation can be hidden to simplify the code and can be reused.\n",
                "\n",
                "Defining a function requires a function name, a set of parameters, and a function body. Functions can also explicitly return a value"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "def squareroot(n):\n",
                "    root = n/2\n",
                "    for k in range(20):\n",
                "        root = (1/2)*(root + (n/root))\n",
                "    return root"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# 5. Object-oriented programming\n",
                "\n",
                "* :: One of the most powerful features of object-oriented programming languages is that they allow programmers (problem solvers) to create entirely new classes to model the data needed to solve a problem\n",
                "\n",
                "* :: Abstract data types have previously been used to provide a logical description of the state and behavior of data objects\n",
                "\n",
                "* :: By constructing classes that implement abstract data types, the abstraction process can be utilized while providing the details necessary to actually apply the abstraction in the program\n",
                "\n",
                "* :: New classes can be created whenever an abstract data type needs to be implemented"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 5.1. basic concepts\n",
                "Everything in Python exists as an object.\n",
                "* :: An object represents a concrete thing in the problem space of the objective world and a fundamental thing in the solution space of a software system.\n",
                "* :: Objects = properties + methods\n",
                "* :: An object is identified by an id, contains data (attributes), code (methods), and is a special instance of a specific class of things"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "id(1)#View Objects"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "type(1)# View the class to which the object belongs."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "dir(1)#View attributes and methods"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "id(abs)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: An object is an instance of a class, the basic unit of a program\n",
                "* :: To create a new object, you must first define a class\n",
                "* :: Objects of the same class have the same properties and methods, but different property values and ids\n",
                "* :: Objects can have multiple names, but only one id\n",
                "* :: Objects realize encapsulation of properties and methods, a data abstraction mechanism"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* Reference form: <object name>. <property name>.\n",
                "* :: If it is a single attribute name, it can be used in assignment statements and expressions as if it were a normal variable\n",
                "* :: It's also easy to call functions of this class, remembering the parentheses\n",
                "* python is a dynamic language, in addition to variables that can be dynamically generated, objects can have attributes or methods added or removed at any time. For example: <object name>. <property name> = 3.6\n",
                "* :: Object-oriented programming is a programming paradigm as well as a program development methodology"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 5.2. class construction [emphasis added].\n",
                "\n",
                "Using the Fraction class as a case\n",
                "\n",
                "Request:\n",
                "\n",
                "* :: Be able to add, subtract, multiply and divide fractions\n",
                "\n",
                "* :: Ability to display scores with a standardized slash\n",
                "\n",
                "* :: The simplest form of the result should be returned\n",
                "\n",
                "Programs:\n",
                "\n",
                "* :: Provide a class name\n",
                "\n",
                "* :: Provide a full set of method definitions with syntax similar to that of function definitions\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class Fraction:\n",
                "    #Define constructor methods\n",
                "    def __init__(self,top,bottom):#self is a special parameter that points to the object itself, must be the first formal parameter, and does not need to be supplied with the corresponding actual parameter when calling the method\n",
                "        # Need state data for both numerator and denominator components\n",
                "        self.num = top\n",
                "        self.den = bottom\n",
                "\n",
                "myfraction = Fraction(3,5)# Create an instance of the class\n",
                "print(myfraction)# prints the actual reference (the address itself)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: Constructor methods define how data objects are created\n",
                "\n",
                "* :: To create an instance of a class, you must call the constructor method. Just use the class name and pass in the actual value of the state, do not call ```__init__``` directly."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#Printing itself instead of quoting\n",
                "class Fraction:\n",
                "    def __init__(self,top,bottom):\n",
                "        self.num = top\n",
                "        self.den = bottom\n",
                "\n",
                "    def show(self):\n",
                "        print(self.num,\"/\",self.den)# have to call the method before printing, not good, want to rewrite the method provided by python\n",
                "        \n",
                "myfraction = Fraction(3,5)# Create an instance of the class\n",
                "print(type(myfraction.show()))#<class 'NoneType'>\n",
                "print(myfraction)# not using this method, then the actual reference (the address itself) is printed"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "And all of python's classes provide a standard set of methods. One can look at the method ```__str__`` which converts an object to a string. The method defaults: it returns the address string as before. Then override the default implementation, or redefine the behavior of the method. The following code is important to show that the classes change in different places\n",
                "\n",
                "**KEY**"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Rewrite the original implementation\n",
                "#Note the category change that occurs, in the str section it is str, but the printed instance is the self-defined Fraction, and the direct presentation of the variable is the actual reference\n",
                "class Fraction:\n",
                "    def __init__(self,top,bottom):\n",
                "        self.num = top\n",
                "        self.den = bottom\n",
                "\n",
                "    def __str__(self):\n",
                "        print(type(str(self.num) + \"/\" + str(self.den)))#这里是<class 'str'>\n",
                "        return str(self.num) + \"/\" + str(self.den)\n",
                "        #return (self.num,\"/\",self.den)#Syntax error, you can't write it like this or you'll get an error __str__ returned non-string (type NoneType)\n",
                "    \n",
                "myfraction = Fraction(3,5)# Create an instance of the class\n",
                "\n",
                "print(myfraction)\n",
                "\n",
                "print(type(myfraction))# The printed data class is <class '__main__.Fraction'>\n",
                "\n",
                "myfraction# returns the actual reference (the address itself) to <__main__.Fraction at 0x256c2689850>; it's not the same as the address of the instance in the previous entry"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Rewritten calls 1\n",
                "myfraction.__str__()# prints str"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Rewritten call 2\n",
                "str(myfraction)#Prints str"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Think about how to define the addition of this class"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "def __add__(self,otherfraction):# note the name of the second argument\n",
                "    newnum = self.num * otherfraction.den + otherfraction.num * self.den\n",
                "    newden = sel.den * otherfraction.den\n",
                "    print(Fraction(newnum,newden))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Merge back into the original class definition\n",
                "\n",
                "class Fraction:\n",
                "    def __init__(self,top,bottom):\n",
                "        self.num = top\n",
                "        self.den = bottom\n",
                "\n",
                "    def __str__(self):\n",
                "        return str(self.num) + \"/\" + str(self.den)\n",
                "\n",
                "    def __add__(self,otherfraction):# note the name of the second argument\n",
                "        newnum = self.num * otherfraction.den + otherfraction.num * self.den\n",
                "        newden = self.den * otherfraction.den\n",
                "        return(Fraction(newnum,newden))# If you use print here, it will cause the last print to be None.\n",
                "\n",
                "myfra = Fraction(3,5)# create instance of class\n",
                "myfrb = Fraction(1,4)\n",
                "print(myfra + myfrb)#Testing with other scores will result in a result that may not be the shortest possible score"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "To compute the simplest fraction, you first need to find the greatest common factor of m and n using the method of division by rolling over (Euclid's algorithm). For example, find the greatest common factor of 105 and 252. 252/105 = 2...42, so the greatest common factor of these two numbers is also 42. .42, then the greatest common factor of these two numbers is also 42, the greatest common factor of 105 (eliminating the parts that agree with each other and leaving the ones that don't, which are the important factors that affect the greatest common factor). The purpose of this algorithm is to reduce the numbers for easier calculation.\n",
                "\n",
                "Continuing with the same calculations reduces the two numbers until the remainder is zero. At that point, the remaining number that has not yet become zero is the greatest common divisor of the two numbers. If 105/42 = 2.... . 21, then it is the greatest common factor of 21 and 42, 21.\n",
                "\n",
                "It can also be deduced from the method of division by rotation that the greatest common divisor of two numbers can be expressed by adding the integer multiples of the two numbers (Pei Shu's theorem), e.g. $21 = 5\\times 42 + (-2) \\times 252$."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#Calculate the simplest fraction\n",
                "\n",
                "def gcd(m,n):\n",
                "    while m%n !=0:\n",
                "        oldm = m\n",
                "        oldn = n\n",
                "        \n",
                "        m = oldn#Note that it ends in n, because the original divisor is necessarily larger compared to the remainder.\n",
                "        n = oldm%oldn#取余数\n",
                "    return n\n",
                "gcd(105,252)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Expand the calculation above and note that the divisor this time is the divisor next time. gcd's two arguments do not need to be ordered by size, because the\n",
                "\n",
                "[m = oldn will update the unchanged ones.]\n",
                "\n",
                "252%105 != 0\n",
                "\n",
                "oldm = 252\n",
                "\n",
                "oldn = 105\n",
                "\n",
                "m = 105\n",
                "\n",
                "n = 42\n",
                "***\n",
                "\n",
                "105%42 != 0\n",
                "\n",
                "oldm = 105\n",
                "\n",
                "oldn = 42\n",
                "\n",
                "m = 42\n",
                "\n",
                "n = 21"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Improved version add\n",
                "def __add__(self,otherfraction):\n",
                "    newnum = self.num * otherfraction.den + self.den * otherfraction.num\n",
                "    newden = self.den * otherfraction.den\n",
                "    common = gcd(newden,newnum)\n",
                "    return Fraction(newnum/common,newden/common)#Single slash here can divide cleanly, but it will cause the numerator and denominator numbers to carry decimal points"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Merged into the definition of the class\n",
                "\n",
                "class Fraction:\n",
                "    def __init__(self,top,bottom):\n",
                "        self.num = top\n",
                "        self.den = bottom\n",
                "\n",
                "    def __str__(self):\n",
                "        return str(self.num) + \"/\" + str(self.den)#记住写法\n",
                "    \n",
                "    def gcd(m,n):\n",
                "        while m%n !=0:\n",
                "            oldm = m\n",
                "            oldn = n\n",
                "            \n",
                "            m = oldn\n",
                "            n = oldm%oldn#取余数\n",
                "        return n\n",
                "\n",
                "    def __add__(self,otherfraction):\n",
                "        newnum = self.num * otherfraction.den + otherfraction.num * self.den\n",
                "        newden = self.den * otherfraction.den\n",
                "        common = gcd(newden,newnum)\n",
                "        #return str(newnum//common) + '/' + str(newden//common) #There's a double slash here, this returns str\n",
                "        return Fraction(newnum//common,newden//common)#这里返回的是<class '__main__.Fraction'>\n",
                "\n",
                "myfra = Fraction(3,5)# create instance of class\n",
                "myfrb = Fraction(1,4)\n",
                "print(type(myfra + myfrb))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Shallow Equivalent and Deep Equivalent\n",
                "\n",
                "* :: Shallow equality: references to the same object will work\n",
                "\n",
                "* :: Equal depth: consistent values are sufficient\n",
                "\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Rewrite the __eq__ method\n",
                "def __eq__(self,other):\n",
                "    firstnum = self.num * other.den\n",
                "    secondnum = self.den * other.num\n",
                "    return firstnum == secondnum"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Rewrite the __le__ method\n",
                "def __le__(self,other):\n",
                "    firstnum = self.num * other.den\n",
                "    secondnum = self.den * other.num\n",
                "    return firstnum < secondnum"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "Full implementation of class #\n",
                "class Fraction:\n",
                "    def __init__(self,top,bottom):\n",
                "        self.num = top\n",
                "        self.den = bottom\n",
                "\n",
                "    def __str__(self):\n",
                "        return str(self.num) + \"/\" + str(self.den)#记住写法\n",
                "    \n",
                "    def gcd(m,n):\n",
                "        while m%n !=0:\n",
                "            oldm = m\n",
                "            oldn = n\n",
                "            \n",
                "            m = oldn\n",
                "            n = oldm%oldn#取余数\n",
                "        return n\n",
                "\n",
                "    def __add__(self,otherfraction):\n",
                "        newnum = self.num * otherfraction.den + otherfraction.num * self.den\n",
                "        newden = self.den * otherfraction.den\n",
                "        common = gcd(newden,newnum)\n",
                "        #return str(newnum//common) + '/' + str(newden//common) #There's a double slash here, this returns str\n",
                "        return Fraction(newnum//common,newden//common)#这里返回的是<class '__main__.Fraction'>\n",
                "    \n",
                "    # Rewrite the __eq__ method\n",
                "    def __eq__(self,other):\n",
                "        firstnum = self.num * other.den\n",
                "        secondnum = self.den * other.num\n",
                "        return firstnum == secondnum\n",
                "    \n",
                "    def __le__(self,other):\n",
                "        firstnum = self.num * other.den\n",
                "        secondnum = self.den * other.num\n",
                "        return firstnum < secondnum\n",
                "    "
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 5.3. Class Inheritance [Difficult].\n",
                "\n",
                "Inheritance relates one class to another. Subclasses inherit features from their parent class, which is also called a superclass\n",
                "\n",
                "By organizing classes into inheritance hierarchies:\n",
                "\n",
                "* :: Object-oriented programming languages enable previously written code to be extended to new application scenarios\n",
                "\n",
                "* :: Better understanding of relationships and more efficient construction of abstract representations\n",
                "\n",
                "Use the circuits for examples. Explanation of with, or, and non gates is omitted\n",
                "\n",
                "Thoughts:\n",
                "\n",
                "1. Generalized characteristics of the most basic logic gates: names and outputs of logic gates\n",
                "\n",
                "2. Characteristics of the logic gates inherited for the first time: whether there is one input or two inputs (also called \"pins\", pin).\n",
                "\n",
                "3. Characterization of the logic gates inherited for the second time: writing by specificity\n",
                "\n",
                "It also needs to be able to give the user access to the labels of the logic gates, and also be able to perform logical calculations"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Superclass LogicGate\n",
                "class LogicGate:\n",
                "    def __init__(self,n):#n is label name\n",
                "        self.label = n\n",
                "        self.output = None#Initially it's nothing.\n",
                "    def getLabel(self):\n",
                "        return self.label#获取标签\n",
                "    def getOutput(self):\n",
                "        self.output = self.performGateLogic()# create a method and implement no details, wait for inheritance and then write specific functions to facilitate code reuse\n",
                "        return self.output"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Introduction to functions commonly used for inheritance: [super](https://www.runoob.com/python/python-func-super.html)\n",
                "\n",
                "1. The super() function is used to call a method of a parent class (superclass). The syntax is as follows ```super(type[, object-or-type])``` The former is the class. The latter is also a class, usually self\n",
                "2. One difference between Python 3.x and Python 2.x is that Python 3 can use ``super().xxx`` directly instead of ``super(Class, self).xxx``.\n",
                "3. The constructor method of the subclass needs to call the constructor method of the parent class first, and then initialize its own unique data.\n",
                "4. Model codes"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class A:\n",
                "     def add(self, x):\n",
                "         y = x+1\n",
                "         print(y)\n",
                "class B(A):\n",
                "    def add(self, x):# Define the add function in a subclass with the same function name, and the same argument form\n",
                "        super().add(x) # from the add function in the parent class\n",
                "b = B()\n",
                "b.add(2)  # 3"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#1 pin (input) gates\n",
                "#Inheritance!\n",
                "class UnaryGate(LogicGate):\n",
                "    def __init__(self,n):\n",
                "        super(). __init__(n)# inherits init from the parent class, and is written in the same way as calling the function\n",
                "        self.pin = None\n",
                "    def getPin(self):\n",
                "        return int(input(\"Enter pin input for gate \" + self.getLabel() + \"-->\"))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#2 pin gate\n",
                "class BinaryGate(LogicGate):\n",
                "    def __init__(self,n):\n",
                "        super().__init__(n)\n",
                "        self.pinA = None\n",
                "        self.pinB = None\n",
                "    \n",
                "    def getPinA(self):\n",
                "        return int(input(\"Enter pin A input for gate \" + self.getLabel() + \"-->\"))\n",
                "\n",
                "    def getPinB(self):\n",
                "        return int(input(\"Enter pin B input for gate \" + self.getLabel() + \"-->\"))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Further define the concrete class by simply adding the Boolean operation"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# and doors\n",
                "class AndGate(BinaryGate):\n",
                "    def __init__(self,n):\n",
                "        super().__init__(n)\n",
                "    def performGateLogic(self):\n",
                "        a = self.getPinA()\n",
                "        b = self.getPinB()\n",
                "        if a == 1 and b == 1:\n",
                "            return 1\n",
                "        elif a*b == 0:\n",
                "            return 0\n",
                "        else:\n",
                "            return 'Error Input!'"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create objects!\n",
                "g1 = AndGate(\"G1\")\n",
                "g1.getOutput()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class NotGate(UnaryGate):\n",
                "    def __init__(self,n):\n",
                "        super().__init__(n)\n",
                "    def performGateLogic(self):\n",
                "        a = self.getPin()\n",
                "        if a == 0:\n",
                "            return 1\n",
                "        elif a == 1:\n",
                "            return 0\n",
                "        else:\n",
                "            return 'Error Input!'"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "g2 = NotGate(\"G2\")\n",
                "g2.getOutput()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class OrGate(BinaryGate):\n",
                "    def __init__(self,n):\n",
                "        super().__init__(n)\n",
                "    def performGateLogic(self):\n",
                "        a = self.getPinA()\n",
                "        b = self.getPinB()\n",
                "        if a == 0 and b == 0 :\n",
                "            return 0\n",
                "        else:\n",
                "            return 1"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "g3 = OrGate(\"g3\")\n",
                "g3.getOutput()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Logic gates have been created, and now the objects need to be connected. The output of the former is the input of the latter (data values \"flow\" from the output of this gate to the input of the other gate). So create a new class Connector\n",
                "\n",
                "Note that the Connector is not in the inheritance hierarchy of these Gates, but it will use that structure -- there is a logical gate on both ends of each Connector object\n",
                "\n",
                "This is the HAS-A relationship: the Connector object contains instances of the LogicGate class internally, but not in the inheritance hierarchy.Connector has a LogicGate\n",
                "\n",
                "When pre-designing classes, it is important to distinguish between IS-A (inheritance required), HAS-A (no inheritance required) relationships"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class Connector:\n",
                "    def __init__(self,fgate,tgate):\n",
                "        self.fromgate = fgate\n",
                "        self.togate = tgate\n",
                "        \n",
                "        tgate.setNextPin(self)\n",
                "        \n",
                "    def getFrom(self):\n",
                "        return self.fromgate\n",
                "    \n",
                "    def getTo(self):\n",
                "        return self.togate"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The setNextPin can be seen as belonging to the logic gate, and needs to be added in, **enabling each togate to select the appropriate input**. But in the BinaryGate class, there are 2 inputs, might as well default to choosing pinA, not work before choosing pinB, if it doesn't work then you can't connect the logic gate.\n",
                "\n",
                "==> Now there are two types of input sources:\n",
                "\n",
                "* :: From external sources\n",
                "* Output from previous logic gate\n",
                "\n",
                "Using AndGate as an example, there is:\n",
                "\n",
                "1. if the input is not connected to any logic gate, then the user is asked to enter the\n",
                "\n",
                "2. if there is a connection, access the connection in order to get the output of the fromgate\n",
                "\n",
                "3. The processing logic for fromgate is triggered at step 2.\n",
                "\n",
                "4. The process continues until each input that affects the final output value is obtained\n",
                "\n",
                "In a sense, the circuit works in reverse to get the required inputs before calculating the final result"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Modified and doors\n",
                "class AndGate(BinaryGate):\n",
                "    def __init__(self,n):\n",
                "        super().__init__(n)\n",
                "    def setNextPin(self,source):\n",
                "        if self.pinA == None:\n",
                "            self.pinA = source\n",
                "        elif self.pinB == None:\n",
                "            self.pinB == source\n",
                "        else:\n",
                "            raise RuntimeError(\"Error:No Empty Pins\")\n",
                "    def performGateLogic(self):\n",
                "        a = self.getPinA()\n",
                "        b = self.getPinB()\n",
                "        if a == 1 and b == 1:\n",
                "            return 1\n",
                "        elif a*b == 0:\n",
                "            return 0\n",
                "        else:\n",
                "            return 'Error Input!'\n",
                "    def getPinA(self):\n",
                "        if self.pinA == None:\n",
                "            return int(input(\"ENTER PIN A FOR GATE \" + \\\n",
                "                         self.getLabel() + \"-->\"))\n",
                "        else:\n",
                "            return self.pinA.getFrom().getOutPut() # setNextPin sets PinA to the linker source, so it can call the getFrom() function\n",
                "    def getPinB(self):\n",
                "        if self.pinB == None:\n",
                "            return int(input(\"ENTER PIN B FOR GATE \" + \\\n",
                "                         self.getLabel() + \"-->\"))\n",
                "        else:\n",
                "            return self.pinB.getFrom().getOutPut()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class OrGate(BinaryGate):\n",
                "    def __init__(self, n) -> None:\n",
                "        super().__init__(n)\n",
                "    def performGateLogic(self):\n",
                "        a = self.getPinA()\n",
                "        b = self.getPinB()\n",
                "        if a == 1 or b == 1:\n",
                "            return 1 \n",
                "        else:\n",
                "            return 0\n",
                "    def setNextPin(self,source):\n",
                "        if self.pinA == None:\n",
                "            self.pinA = source\n",
                "        else:\n",
                "            if self.pinB == None:\n",
                "                self.pinB = source\n",
                "            else:\n",
                "                raise RuntimeError(\"Error:no empty pins\")\n",
                "    def getPinA(self):\n",
                "        if self.pinA == None:\n",
                "            return int(input(\"ENTER PIN A FOR GATE \" + \\\n",
                "                         self.getLabel() + \"-->\"))\n",
                "        else:\n",
                "            return self.pinA.getFrom().getOutPut()\n",
                "    def getPinB(self):\n",
                "        if self.pinB == None:\n",
                "            return int(input(\"ENTER PIN B FOR GATE \" + \\\n",
                "                         self.getLabel() + \"-->\"))\n",
                "        else:\n",
                "            return self.pinB.getFrom().getOutPut()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class NotGate(UnaryGate):\n",
                "    def __init__(self, n) -> None:\n",
                "        super().__init__(n)\n",
                "    def performGateLogic(self):\n",
                "        a = self.getPin()\n",
                "        if a == 1 :\n",
                "            return 0 \n",
                "        else:\n",
                "            return 1\n",
                "    def setNextPin(self,source):\n",
                "        if self.pin == None:\n",
                "            self.pin = source#Set the linker\n",
                "        else:\n",
                "            raise RuntimeError(\"Error:no empty pins\")\n",
                "    def getPin(self):\n",
                "        if self.pin == None:\n",
                "            return int(input(\"ENTER PIN FOR GATE\" + \\\n",
                "                         self.getLabel() + \"-->\"))\n",
                "        else:\n",
                "            return self.pin.getFrom().getOutPut()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "******"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# [Supplemental]"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# 6. Definition and invocation of classes"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 6.1. Definition of classes\n",
                "* :: Classes are templates for objects that encapsulate the properties and behaviors of the corresponding real entities\n",
                "* :: Instance objects are concretizations of classes\n",
                "* :: The class is the mold and the object is the part made by the mold\n",
                "* :: The emergence of classes provides a means of realizing three of the most important characteristics of object-oriented programming: encapsulation, inheritance, and polymorphism [the same piece of code can handle different objects, even of different types].\n",
                "* :: Custom classes, starting with an uppercase letter. Functions start with a lowercase letter. This is because classes and functions are used in exactly the same form at the time of use\n",
                "* :: Define class: class<class name>.\n",
                "* :: Class initialization:\n",
                "    class<class name>.\n",
                "        def __init__(self,<parameter list>).\n",
                "* The first argument to a function of a class is always self, and in a method of a class, self refers to the object instance itself.\n",
                "* :: Call: <class name> (<argument>)\n",
                "* :: Addition returns the object of the regenerated force"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 6.2. Special Methods in Class Definitions"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* Special methods are also known as magic methods. Implementing special methods in class definitions makes it easy to use built-in operations in python.\n",
                "* :: All special methods begin and end with two underscores\n",
                "* :: Object constructor: __init__(sekf,[])\n",
                "* :: Analyzer: __del(self, [])"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "from os.path import join\n",
                "class FileObject:\n",
                "    def __init__(self,filepath = '~',filename = 'sample.txt') -> None:\n",
                "        self.file = open(join(filepath,filename),'r4')\n",
                "    def __del__(self):\n",
                "        self.file.close()\n",
                "        del self.file"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "from manim import *\n",
                "\n",
                "config.media_width = \"75%\"\n",
                "config.verbosity = \"WARNING\""
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "%%manim -qm CircleToSquare\n",
                "\n",
                "class CircleToSquare(Scene):\n",
                "    def construct(self):\n",
                "        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n",
                "        green_square = Square(color=GREEN, fill_opacity=0.8)\n",
                "        self.play(Create(blue_circle))\n",
                "        self.wait()\n",
                "        \n",
                "        self.play(Transform(blue_circle, green_square))\n",
                "        self.wait()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* Arithmetic operator:\n",
                "  1) __add__(self,other)\n",
                "  2) __sub__(self,other)\n",
                "  3) __mul__(self,other)\n",
                "  4) __div__(self,other)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: Inverse operation: self as right operand\n",
                "  1) __radd__(self,other)\n",
                "  2) __rsub__(self,other)\n",
                "  3) __rmul__(self,other)\n",
                "  4) __rdiv__(self,other)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: Size comparisons\n",
                "1) __eq__(self,other)\n",
                "2) __ne__(self,other)\n",
                "3) __lt__(self,other):<\n",
                "4) __gt__(self,other):>\n",
                "5) __le__(self,other):<=\n",
                "6) __ge__(self,other):>="
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: If the special function itself already meets the requirements, then just underline __special method__ = special method"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: String manipulation\n",
                "  1) __str__(self)#Automatically convert to string\n",
                "  2) __repr__(self)# Formal expression of the object\n",
                "  3) __len__(self)# Returns the number of elements."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# 7. Sorting of custom objects"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 7.1. list sorting"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: The list method sort(), which sorts by content, changes the contents of the original list.\n",
                "* :: Defaults to ascending order if all are numbers\n",
                "* :: If the elements are all strings, they are sorted alphabetically\n",
                "* :: sorted(): return sorted, original list content unchanged\n",
                "* :: sort() and sorted() only work properly if the list elements are of the same type. Because of the __lt__ special method based: the method should return True"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# 8. Class inheritance"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: Inheritance facilitates code reuse\n",
                "* class <subclass name> (<parent class name>).\n",
                "      def <redefine method>(self,...) :\n",
                "* That's overriding override\n",
                "* It is also possible to add methods and properties that are not present in the parent class:"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class Car:\n",
                "    def __init__(self,name) -> str:# -> type: doesn't affect original type\n",
                "        self.name = name\n",
                "        self.remain_mile = 0\n",
                "\n",
                "class GasCar(Car):\n",
                "    def __init__(self, name,capacity) -> None:\n",
                "        super(). __init__(name)# parent class initialization method, name only\n",
                "        # In __init__(name), only Name is reinitialized because only the name parameter is used in Car's initialization.\n",
                "        self.remain_mile = 70\n",
                "        self.capacity = capacity#新添加方法\n",
                "\n",
                "a = Car('BMW')\n",
                "print(type(a))\n",
                "\n",
                "b = GasCar('BMW',60)\n",
                "print(b.remain_mile)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: The role of self: inside the class, all data passed in during instantiation are given to this variable\n",
                "* :: This variable is not related to the class, it is a separate instance variable\n",
                "* :: self represents an object instance\n",
                "* :: gcar.run(200.0) is equivalent to GasCar.run(gcar,200.0)"
            ]
        }
    ],
    "metadata": {
        "kernelspec": {
            "display_name": "base",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.12.7"
        },
        "toc": {
            "base_numbering": 1,
            "nav_menu": {},
            "number_sections": false,
            "sideBar": false,
            "skip_h1_title": false,
            "title_cell": "Table of Contents",
            "title_sidebar": "Contents",
            "toc_cell": true,
            "toc_position": {
                "height": "392.4px",
                "left": "120px",
                "top": "110.525px",
                "width": "266px"
            },
            "toc_section_display": true,
            "toc_window_display": true
        }
    },
    "nbformat": 4,
    "nbformat_minor": 2
}