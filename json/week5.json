{
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "[Thought for the week]\n",
                "This week's and next week's classes are all about learning recursion, and next week's class will cover some of dynamic programming. Here is this week's syllabus:\n",
                "* :: 401 What is recursion\n",
                "* :: 402 Application of recursion\n",
                "* :: 403 Implementation of recursion\n",
                "* :: 404-405 Visualization of recursion\n",
                "* :: 406-407 Application of recursion"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "**Table of contents**<a id='toc0_'></a>    \n",
                "- [401 What is recursion](#toc1_)\n",
                "  - [1. Cases] (#toc1_1_)\n",
                "  - [2. Three laws of recursion [emphasis added]](#toc1_2_)\n",
                "- [402 Application of recursion: arbitrary conversion](#toc2_)\n",
                "  - [1. Issues] (#toc2_1_)\n",
                "  - [2. Algorithms] (#toc2_2_)\n",
                "- [403 Implementation of recursive calls](#toc3_)\n",
                "  - [1. Relationship between recursion and stack](#toc3_1_)\n",
                "- [404 Recursive visualization: fractal trees](#toc4_)\n",
                "  - [Fractal trees: self-similar recursive graphs](#toc4_1_)\n",
                "- [405 Recursive visualization: the Serbinsky triangle](#toc5_)\n",
                "  - [1. Title] (#toc5_1_)\n",
                "  - [2. Algorithms] (#toc5_2_)\n",
                "- [ 406 Application of Recursion: Hannukah](#toc6_)\n",
                "  - [1. Issues] (#toc6_1_)\n",
                "  - [2. Algorithms] (#toc6_2_)\n",
                "- [407 Applications of recursion: exploring mazes](#toc7_)\n",
                "  - [1. Issues] (#toc7_1_)\n",
                "  - [Algorithm](#toc7_2_)\n",
                "- [Assignment] (#toc8_)\n",
                "\n",
                "<!-- vscode-jupyter-toc-config\n",
                "\tnumbering=false\n",
                "\tanchor=true\n",
                "\tflat=false\n",
                "\tminLevel=1\n",
                "\tmaxLevel=6\n",
                "\t/vscode-jupyter-toc-config -->\n",
                "<!-- THIS CELL WILL BE REPLACED ON TOC UPDATE. DO NOT WRITE YOUR TEXT IN THIS CELL -->"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc1_'></a>[401 What is recursion](#toc0_)\n",
                "\n",
                "Essence: break down the problem into smaller [identical] problems\n",
                "* :: Continuous decomposition: knowing that the problem is small enough to be solved in a very simple way\n",
                "* :: Characterization of recursion: [calling itself] in the algorithmic flow\n",
                "\n",
                "Note that the final order is the same as the stack, which will be reversed. Please refer to the following example"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc1_1_'></a>[1. case](#toc0_)\n",
                "\n",
                "Given a list, return the sum of all numbers\n",
                "\n",
                "The condition is that the number of items in the list is indeterminate and a loop statement cannot be used.\n",
                "\n",
                "Analyze there:\n",
                "Each step performs addition, which has exactly 2 operands\n",
                "\n",
                "$\\implies$ breaks down the problem of summing a large list of numbers into a smaller and fixed sum of 2 numbers.\n",
                "i.e.\n",
                "Sum of $$ series = first number + sum of the remaining series $$\n",
                "\n",
                "If the series contains as few as 1 number, its sum is this number\n",
                "\n",
                "$\\implies$ 递归"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Summing up the series\n",
                "def listSum(numList):\n",
                "    if len(numList) == 1:\n",
                "        return numList[0]\n",
                "    else:\n",
                "        return numList[0]+listSum(numList[1:])# With this line, each recursion essentially updates numList; see the debugging process in try.py\n",
                "print(listSum([1,3,5,7,9]))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The reference explanations are\n",
                "\n",
                "<img src=\"./img/401.png\">"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc1_2_'></a> [2. Three laws of recursion [emphasis added]](#toc0_)\n",
                "* Recursive algorithms must have a fundamental end condition $\\implies$ the direct solution of the minimum size problem\n",
                "* :: Recursive algorithms must be able to change states to evolve towards basic end conditions $\\implies$ to reduce the size of the problem\n",
                "* Recursive algorithms must call themselves $\\implies$ to solve the same problem with reduced scale\n",
                "\n",
                "The call itself is harder to understand, so it might be better to understand it:\n",
                "\n",
                "Problems are broken down into smaller identical problems [nesting]"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Combining the series summation algorithm against the recursion condition has:\n",
                "* :: Has a basic end condition: when the list length is 1, it directly outputs the number of unique numbers included\n",
                "* :: The recursive algorithm is: change the list and evolve to a state of length 1\n",
                "* :: Calling itself: solving sums of shorter series"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc2_'></a>[402 Application of recursion: arbitrary binary conversion](#toc0_)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc2_1_'></a>[1. question](#toc0_)\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc2_2_'></a> [2. Algorithm](#toc0_)\n",
                "Think about this in terms of converting to decimal as an example:\n",
                "1. For integers smaller than ten, look up the table directly: ```convString[n]``''\n",
                "2. Whole numbers smaller than ten, broken down into a series of whole numbers smaller than ten against the base, and then looked up in a table one by one\n",
                "\n",
                "$\\implies$\n",
                "\n",
                "* :: Find the basic end condition: integers less than ten, and perform a look-up table transformation\n",
                "* :: Evolution to the \"basic end condition\": the process of dismantling the greater-than-ten through base splitting\n",
                "\n",
                "The algorithm needs to call itself, i.e., roll over and divide:\n",
                "\n",
                "* :: Divided by \"base base\" (//base)\n",
                "* :: Find the corresponding (% base) by taking the remainder of the \"base\".\n",
                "\n",
                "Referring to the following figure, it is worthwhile to consider \"769\" as a decimal, and check whether there is any error in converting it to decimal."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "<img src=\"./img/402.png\">"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "def toStr(n,base):\n",
                "    convertString = \"0123456789ABCDEF\"\n",
                "    if n < base:\n",
                "        return convertString[n]#查表\n",
                "    else:\n",
                "        return toStr(n//base,base) + convertString[n%base]# the former continues the recursion, the latter looks up the table to determine the corresponding symbols\n",
                "print(toStr(1453,16))\n",
                "#print(type(toStr(1453,16)))\n",
                "#print(int(toStr(1453,16)))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Process for:\n",
                "\n",
                "1453 ÷ 16 = 90 余 13 → 'D'\n",
                "\n",
                "90 ÷ 16 = 5 余 10 → 'A'\n",
                "\n",
                "5 ÷ 16 = 0 余 5 → '5'\n",
                "\n",
                "Recursive splicing results in \"5\" + \"A\" + \"D\" = \"5AD\" (hexadecimal)\n",
                "\n",
                "$\\implies$\n",
                "\n",
                "**Please note that the order is reversed! **"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc3_'></a>[403 Implementation of recursive calls](#toc0_)\n",
                "\n",
                "## <a id='toc3_1_'></a>[1. Relationship between recursion and stack](#toc0_)\n",
                "\n",
                "When a function is called, the system presses the field data from the call onto the system call stack. Where the field data includes:\n",
                "    * :: Parameter values of functions\n",
                "    * :: Local variable values within functions\n",
                "    * :: The return address of the function (the location of the code that should be returned at the end of the call)\n",
                "    * :: Current status of the register\n",
                "    * :: The return value of the function (if any)\n",
                "\n",
                "* :: When a recursive call occurs, the system automatically presses the live data into the call stack in memory, forming a stack frame.\n",
                "* :: Each recursive call creates a new stack frame\n",
                "* :: When the recursion returns (the most basic termination condition is reached), the system pops the stack frame in a last-in-first-out (LIFO) order, restoring the previous execution site"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Reference 1\n",
                "\n",
                "<img src=\"./img/403.png\">\n",
                "\n",
                "The basic end condition is triggered at $1 < 2$, i.e. you can return the"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#Reference 2\n",
                "def factorial(n):\n",
                "    if n == 0:\n",
                "        return 1\n",
                "    else:\n",
                "        return n * factorial(n-1)\n",
                "    \n",
                "factorial(3)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "When factorial(3) is called:\n",
                "\n",
                "* :: Press-in parameter n=3 on first call\n",
                "* :: Save the current value of n=3 to the stack for recursive calls to n=2\n",
                "* :: Continuing recursive calls to n=1, saving the state of n=2\n",
                "* :: Start returning layer by layer when n = 0 at the end, restoring the previous value of n each time the stack frame is popped up\n",
                "\n",
                "This mechanism ensures that recursive calls can correctly backtrack to a previous state of execution, but it is important to be aware of Python's default recursion depth limit (which can be adjusted with ``sys.setrecursionlimit()```)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Recursion depth limits in python:\n",
                "\n",
                "* :: RecursionError: usually there are too many recursion levels and the system calls take up limited capacity. It can be checked from the following:\n",
                "    * :: No stopping conditions\n",
                "    * :: Recursion evolves too slowly, leading to too many layers of recursion and call stack overflow"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# No stopping conditions\n",
                "def tell_story():\n",
                "    print (\"Once upon a time there was a mountain, and on the mountain there was a temple, and in the temple there was an old monk, and he was speaking\")\n",
                "    tell_story()\n",
                "\n",
                "print(\"I'll tell you a story.\")\n",
                "tell_story()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The maximum recursion depth can be obtained and adjusted in Python's built-in sys module"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "import sys\n",
                "sys.getrecursionlimit()\n",
                "sys.setrecursionlimit(3000)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc4_'></a>[404 Recursive visualization: fractal trees](#toc0_)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Turtle mapping system turtle module, a simple example is as follows"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "import turtle\n",
                "t = turtle.Turtle()\n",
                "\n",
                "t.forward(100)\n",
                "\n",
                "# End of mapping\n",
                "turtle.done()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Now the recursive graphing begins with the idea that the\n",
                "* :: Minimum size: ```if linelen > 0``''\n",
                "* :: Reduce size & call itself: ``drawSpiral(t,linelen - 5)''"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Recursive visualization\n",
                "import turtle\n",
                "t = turtle.Turtle()\n",
                "\n",
                "def drawSpiral(t,lineLen):\n",
                "    if lineLen > 0:\n",
                "        t.forward(lineLen)\n",
                "        t.right(90)\n",
                "        drawSpiral(t,lineLen - 5)\n",
                "\n",
                "drawSpiral(t,100)\n",
                "\n",
                "turtle.done()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "import turtle\n",
                "t = turtle.Turtle()\n",
                "\n",
                "def drawSpiral(t, lineLen):\n",
                "    if lineLen > 0:\n",
                "        t.forward(lineLen)\n",
                "        t.right(90)\n",
                "        drawSpiral(t, lineLen - 5)\n",
                "    t.hideturtle()\n",
                "  \n",
                "\n",
                "drawSpiral(t, 100)\n",
                "turtle.bye() # force the Turtle graphics window to close\n",
                "#turtle.clearscreen() # optional: clears the canvas"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc4_1_'></a>[Fractal trees: self-similar recursive graphs](#toc0_)\n",
                " \n",
                "What is a fractal?\n",
                "\n",
                "Definition: a fractal is a geometric structure or mathematical model with **self-similarity** and **infinite detail** [the whole is similar to its parts]\n",
                "\n",
                "Core features include:\n",
                "\n",
                "1. **Self-similarity**\n",
                "   The local structure of a fractal bears a statistical or exact resemblance to the overall form at any scale. Example:\n",
                "   - **Koch snowflake**: the subdivisions of each side generate small triangles similar to the original side.\n",
                "   - **Mandebo collection**: its borders show a complex pattern similar to the whole even after magnification.\n",
                "\n",
                "2. **Non-integer dimensions**\n",
                "   The dimension of a fractal (fractal dimension) can be a fraction, for example:\n",
                "   - The dimension of the Koch curve is $ \\frac{\\log 4}{\\log 3} \\approx 1.26 $\n",
                "   - The dimension of the Shelbinski carpet is $\\frac{\\log 8}{\\log 3} \\approx 1.89 $\n",
                "\n",
                "3. **Iterative generation**\n",
                "   Fractals are usually generated by recursive rules. For example, the Mandelbrot set is defined by an iterative formula in the complex plane that computes divergence to produce an infinitely replicated boundary\n",
                "$$\n",
                "   z_{n+1} = z_n^2 + c  \\quad\n",
                "$$"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: Fractal features present in natural phenomena that allow computers to generate very realistic natural scenes through fractal algorithms\n",
                "* :: Fractals are things that have similarities at different scales\n",
                "* :: Use of recursive algorithms because of self-similar features"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "How do recursive algorithms handle fractal trees?\n",
                "  \n",
                "<img src=\"./img/404.png\">"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "\n",
                "* :: Basic end condition: stop when trunk length is too short\n",
                "* :: Reducing the size of the problem: each recursive call must bring the problem size closer to the basic end condition, i.e., reduce the length of the branches and the depth of the recursion at each recursion\n",
                "* :: Calling itself: decomposing the tree into three parts: trunk, left subtree, right subtree; forming a self-similar structure"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Theory completed, realization begun"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "import turtle\n",
                "\n",
                "t = turtle.Turtle()\n",
                "t.left(90)#Adjust direction vertically upward\n",
                "\n",
                "def tree(branch_len):\n",
                "    if branch_len > 5:\n",
                "        t.forward(branch_len)\n",
                "        # Right branch\n",
                "        t.right(20)\n",
                "        tree(branch_len - 15)# Assume that each process goes back to the original place\n",
                "        # Left branch\n",
                "        t.left(40)# need to turn double left (offset right turn by 20° and add left turn by 20°)\n",
                "        tree(branch_len - 15)\n",
                "        # Return to the origin\n",
                "        t.right(20)# back to the right direction (offset with 20° to the left)\n",
                "        t.backward(branch_len)#return to starting point\n",
                "\n",
                "tree(75)\n",
                "turtle.bye()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Further optimization is as follows:"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "import turtle\n",
                "\n",
                "def tree(branch_len):\n",
                "    if branch_len > 5:\n",
                "        t.forward(branch_len)\n",
                "        t.right(20)\n",
                "        tree(branch_len - 15)\n",
                "        t.left(40)\n",
                "        tree(branch_len - 15)\n",
                "        t.right(20)\n",
                "        t.backward(branch_len)#attention there is always the EndPlot where no matter turn left/right/backward\n",
                "        #on the endplot,it always return back to the fork point and turn left\n",
                "\n",
                "t = turtle.Turtle()\n",
                "t.left(90)\n",
                "t.penup()\n",
                "t.backward(100)#Backward 100 steps without leaving a trace\n",
                "t.pendown()\n",
                "t.pencolor('green')\n",
                "t.pensize(2)\n",
                "tree(75)\n",
                "t.hideturtle()\n",
                "turtle.done()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Description of the global variable t in the supplementary code\n",
                "\n",
                "$\\implies$\n",
                "\n",
                "The reason t can be called directly by the tree function in this code is the scoping rules:\n",
                "\n",
                "* :: Global scoping: the variable ```t = turtle.Turtle()``` is defined in module-level scoping (global scoping)\n",
                "\n",
                "* :: Function access rules: Python functions can read variables in the outer scope directly. The ```tree()``` function is defined after t, though, due to:\n",
                "    * No assignment operation is performed on t (i.e., no t = ... statement)\n",
                "    * :: Call only methods of t (e.g., t.right()/t.forward())\n",
                "    \n",
                "    $\\implies$ and therefore does not require the use of the ``global t`` declaration.\n",
                "\n",
                "* :: Object mutability: t is an instance of the Turtle object, and all direction/position changes are realized by modifying object properties. Although the state of the turtle is changed within the function, this is a legal operation"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc5_'></a>[405 Recursive visualization: the Serpinski triangle](#toc0_)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc5_1_'></a> [1. title](#toc0_)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "This is a typical fractal configuration\n",
                "* :: The planar one is called the Serbinsky triangle.\n",
                "* :: The three-dimensional one is called the Serpensky Pyramid.\n",
                "\n",
                "\n",
                "\n",
                "Construction Methods:\n",
                "\n",
                "* :: Recursive segmentation: start with a solid equilateral triangle, split it into 4 identical small triangles, remove the center triangle, and repeat the process for the remaining 3 small triangles, iterating indefinitely to form the final pattern\n",
                "* :: Random iterative method (chaos game): randomly select a starting point, then repeatedly select one of the vertices of the triangle, move the current point to half the distance from the selected vertex, and ultimately generate the Scherbinski triangle\n",
                "\n",
                "\n",
                "In fact, the true Scherbinski triangle is completely invisible, with area 0 but infinite perimeter, and is a fractional-dimensional (~1.585-dimensional) construction intermediate between one and two dimensions"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: According to the self-similarity feature, the Scherbinski triangle is made of three Scherbinski triangles of halved dimensions stacked in a zigzag pattern\n",
                "* :: Can only make a limited approximation of the degree in practice"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc5_2_'></a> [2. Algorithm](#toc0_)\n",
                "In the case of finite degree, a triangle with $degree = n$ is formed by stacking 3 triangles with $degree = n-1$ according to Pin\n",
                "* All three $degree = n-1$ triangles have half the side lengths of the $degree = n$ triangles [scale reduction].\n",
                "* When $degree = 0$, it is an ordinary equilateral triangle [recursion basic end condition].\n",
                "* :: Self-similarity [call itself]\n",
                "\n",
                "Theory complete, start realizing [using turtle]"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 1,
            "metadata": {},
            "outputs": [],
            "source": [
                "# It's a little harder here, let's get the wheel right first #\n",
                "# Import turtle drawing library\n",
                "import turtle\n",
                "\n",
                "def drawTriangle(points, color):\n",
                "    \"\"\"Draws and fills a triangle\n",
                "    Parameters.\n",
                "        points (dict): A dictionary containing the coordinates of the three vertices, with the following keys.\n",
                "            - top: vertex coordinate (x,y)\n",
                "            - left: coordinates of the lower left corner (x,y)\n",
                "            - right: coordinates of the lower right corner (x,y)\n",
                "        color (str): the name of the fill color or hexadecimal color code \"\"\"\n",
                "    \n",
                "    # Set the fill color\n",
                "    t.fillcolor(color)\n",
                "    \n",
                "    # Lift the brush and move to the vertex\n",
                "    t.penup()\n",
                "    t.goto(points['top'])\n",
                "    \n",
                "    # Start drawing the path\n",
                "    t.pendown()\n",
                "    t.begin_fill()\n",
                "    \"\"\"\n",
                "    t.begin_fill() is the start marker for the fill color, used in conjunction with t.end_fill(). What it does:\n",
                "\n",
                "    1. Mark the start point of the fill: after calling begin_fill(), the closed path formed by the turtle's movement will be used as the area to be filled.\n",
                "    2. it has nothing to do with drawing lines: the actual drawing of lines is done by movement methods such as goto() or forward()\n",
                "    3. color effective rules: need to set the fill color in advance through t.fillcolor()\n",
                "\n",
                "    \"\"\"\n",
                "    \n",
                "    # Join the three vertices in turn to form a closed triangle #\n",
                "    # Please note that it's an up-right-left-right order # # Back to square one #\n",
                "    t.goto(points['left'])\n",
                "    t.goto(points['right'])\n",
                "    t.goto(points['top']) # go back to the starting point to close the path\n",
                "    \n",
                "    # End Fill\n",
                "    t.end_fill()\n",
                "\n",
                "def getMid(p1,p2):\n",
                "    return ((p1[0]+p2[0])/2,(p1[1]+p2[1])/2)\n",
                "\n",
                "\n",
                "points = {'left':(-200,-100),\n",
                "            'top':(0,200),\n",
                "            'right':(200,-100)}\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "def sierpinski(degree,points):\n",
                "    colormap = ['blue','red','green','white','yellow','orange']\n",
                "    drawTriangle(points,colormap[degree])\n",
                "    if degree > 0:# here reconstruct points\n",
                "        # Three per degree is enough #\n",
                "        # Draw the triangle on the left\n",
                "        sierpinski(degree - 1,{\n",
                "            'left':points['left'],\n",
                "            'top':getMid(points['left'],points['top']),\n",
                "            'right':getMid(points['left'],points['right'])\n",
                "        })\n",
                "        # Draw the top triangle\n",
                "        sierpinski(degree - 1,{\n",
                "            'top':points['top'],\n",
                "            'left':getMid(points['top'],points['left']),\n",
                "            'right':getMid(points['right'],points['top'])\n",
                "        })\n",
                "        # Draw the right triangle\n",
                "        sierpinski(degree - 1,{\n",
                "            'right':points['right'],\n",
                "            'top':getMid(points['right'],points['top']),\n",
                "            'left':getMid(points['right'],points['left'])\n",
                "        })\n",
                "\n",
                "# Create the Turtle Brush object\n",
                "t = turtle.Turtle()\n",
                "sierpinski(5,points)\n",
                "turtle.done()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc6_'></a>[ 406 Applications of recursion: Hannukah](#toc0_)\n",
                "\n",
                "## <a id='toc6_1_'></a>[1. Question](#toc0_)\n",
                "The French mathematician Edouard Lucas formulated this complex recursive problem in 1883 based on the legend: the Hannauta.\n",
                "* :: There are 3 pillars\n",
                "* :: One of them has 64 gold disks ranging from small to large.\n",
                "\n",
                "The $\\implies$ monks need to move this stack of gold disks from one pillar to another, but need to follow 2 rules:\n",
                "* :: One at a time\n",
                "* :: Large plates cannot be stacked on top of small plates\n",
                "\n",
                "How long will it take to complete the migration?"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc6_2_'></a> [2. Algorithm](#toc0_)\n",
                "Disassembly according to the three laws of recursion\n",
                "* :: Basic end conditions [minimum size problem]\n",
                "* :: Downsizing\n",
                "* :: Calling itself\n",
                "\n",
                "Here's the key thing: before moving the big plate, you need to empty a column to prepare it\n",
                "\n",
                "$\\implies$ because there are 3 columns, one is being used for the big plate (the start column), one is empty (ready to be used for the big plate, which is the target column), and the other one is necessarily basing the smaller plates in front of it (also called the middle column)\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Corresponding to the recurrence triple law, the analysis has\n",
                "* :: Basic end conditions: end by moving only the smallest plate\n",
                "* :: Scale down: key components analyzed in the previous cell\n",
                "* Call itself: $n$ plates are moved along the same lines as the previous $n-1$ plates.\n",
                "\n",
                "That is, it can be downsized from $n$ plates to 3, to 2, to 1\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Summarize how to move the disk tower from the start column, through the middle column, to the target column.\n",
                "* :: Move the upper tower of $n-1$ disks from the start column, through the target column, to the **intermediate column**.\n",
                "* :: Move the largest disk from the start column to the target column\n",
                "* :: Finally, $n-1$ disks placed in the center column, **through the start column**, are moved to the target column\n",
                "\n",
                "Keep recursing until you get to: the problem of moving 1 disk\n",
                "\n",
                "The theory is complete and the realization begins!"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "Moving disk[1] from #1 to #3\n",
                        "Moving disk[2] from #1 to #2\n",
                        "Moving disk[1] from #3 to #2\n",
                        "Moving disk[3] from #1 to #3\n",
                        "Moving disk[1] from #2 to #1\n",
                        "Moving disk[2] from #2 to #3\n",
                        "Moving disk[1] from #1 to #3\n",
                        "Moving disk[4] from #1 to #2\n",
                        "Moving disk[1] from #3 to #2\n",
                        "Moving disk[2] from #3 to #1\n",
                        "Moving disk[1] from #2 to #1\n",
                        "Moving disk[3] from #3 to #2\n",
                        "Moving disk[1] from #1 to #3\n",
                        "Moving disk[2] from #1 to #2\n",
                        "Moving disk[1] from #3 to #2\n",
                        "Moving disk[5] from #1 to #3\n",
                        "Moving disk[1] from #2 to #1\n",
                        "Moving disk[2] from #2 to #3\n",
                        "Moving disk[1] from #1 to #3\n",
                        "Moving disk[3] from #2 to #1\n",
                        "Moving disk[1] from #3 to #2\n",
                        "Moving disk[2] from #3 to #1\n",
                        "Moving disk[1] from #2 to #1\n",
                        "Moving disk[4] from #2 to #3\n",
                        "Moving disk[1] from #1 to #3\n",
                        "Moving disk[2] from #1 to #2\n",
                        "Moving disk[1] from #3 to #2\n",
                        "Moving disk[3] from #1 to #3\n",
                        "Moving disk[1] from #2 to #1\n",
                        "Moving disk[2] from #2 to #3\n",
                        "Moving disk[1] from #1 to #3\n"
                    ]
                }
            ],
            "source": [
                "# Realize the outline of each step first\n",
                "def moveTower(height,fromPole,withPole,toPole):\n",
                "    if height >= 1:# Basic end condition\n",
                "        moveTower(height - 1,fromPole,toPole,withPole)\n",
                "        moveDisk(height,fromPole,toPole)\n",
                "        moveTower(height - 1,withPole,fromPole,toPole)\n",
                "\n",
                "def moveDisk(disk,fromPole,toPole):\n",
                "    print(f\"Moving disk[{disk}] from {fromPole} to {toPole}\")\n",
                "\n",
                "moveTower(5,\"#1\",\"#2\",\"#3\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "def moveTower(height,fromPole,withPole,toPole):\n",
                "    if height >= 1:\n",
                "        moveTower(height - 1,fromPole,toPole,withPole)#从1到n-1个盘\n",
                "        moveDisk(height,fromPole,toPole)#第n个盘子\n",
                "        moveTower(height - 1,withPole,fromPole,toPole)\n",
                "\n",
                "def moveDisk(disk,fromPole,toPole):\n",
                "    print(f\"Moving disk[{disk}] from {fromPole} to {toPole}\")\n",
                "\n",
                "moveTower(3,\"#1\",\"#2\",\"#3\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc7_'></a>[407 Application of recursion: exploring mazes](#toc0_)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc7_1_'></a>[1. Question](#toc0_)\n",
                "The maze is a rectangular space, divided into neatly organized squares, distinguishing between walls and passages: i.e., each square has a row position and is assigned the attribute \"wall\" and \"passage\". So, how to find the exit?\n",
                "\n",
                "\n",
                "Implementation of the maze data structure:\n",
                "* :: Use of lists (lists whose data items are lists of characters) to store the contents of the box $\\implies$, i.e., two-level lists\n",
                "* :: The use of different characters to represent: walls (\"+\"), channels (\"\"), turtle drop-off points (\"S\").\n",
                "* :: Reading maze data line by line from a text file\n",
                "\n",
                "$\\implies$ can be edited using a text editor maze"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#**********Maze*******************\n",
                "\n",
                "class Maze:\n",
                "    def __init__(self,mazeFileName):\n",
                "        rowsInMaze = 0\n",
                "        columnsInMaze = 0\n",
                "        self.mazelist = []\n",
                "        mazeFile = open(mazeFileName,'r')\n",
                "        rowsInMaze = 0\n",
                "        for line in mazeFile:\n",
                "            rowList = []\n",
                "            col = 0\n",
                "            for ch in line[:-1]:\n",
                "                rowList.append(ch)\n",
                "                if ch == 'S':\n",
                "                    self.startRow = rowsInMaze\n",
                "                    self.startCol = col\n",
                "                col = col + 1\n",
                "            rowsInMaze = rowsInMaze + 1\n",
                "            self.mazelist.append(rowList)\n",
                "            columnsInMaze = len(rowList)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 1,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Constant Definitions\n",
                "OBSTACLE = '+'\n",
                "TRIED = '.'\n",
                "DEAD_END = '-'\n",
                "PART_OF_PATH = 'O'\n",
                "\n",
                "class Maze:\n",
                "    def __init__(self, mazeFileName):\n",
                "        with open(mazeFileName, 'r') as mazeFile:\n",
                "            self.mazelist = []\n",
                "            for row, line in enumerate(mazeFile):\n",
                "                line = line.rstrip('\\n') # handle line breaks\n",
                "                rowList = []\n",
                "                for col, ch in enumerate(line):\n",
                "                    rowList.append(ch)\n",
                "                    if ch == 'S':\n",
                "                        self.startRow = row\n",
                "                        self.startCol = col\n",
                "                self.mazelist.append(rowList)\n",
                "        self.rows = len(self.mazelist)\n",
                "        self.columns = len(self.mazelist[0]) if self.rows > 0 else 0\n",
                "\n",
                "    def __getitem__(self, index):\n",
                "        return self.mazelist[index]\n",
                "\n",
                "    def isExit(self, row, col):\n",
                "        # The exit needs to be a boundary and a space\n",
                "        return (row == 0 or row == self.rows-1 or \n",
                "                col == 0 or col == self.columns-1) and self.mazelist[row][col] == ' '\n",
                "\n",
                "    def updatePosition(self, row, col, status=None):\n",
                "        # Update path status (turtle mapping logic needs to be integrated here)\n",
                "        if status:\n",
                "            self.mazelist[row][col] = status"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "After determining the data structure of the maze, think about the turtles:\n",
                "* ♪ Must be in a square\n",
                "* :: The direction in which it can move must follow the passageway\n",
                "* :: If there's a wall in one direction, move in another direction."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc7_2_'></a> [2. Algorithm](#toc0_)\n",
                "The draft recursive algorithm idea for exploring the maze is as follows.\n",
                "* :: Move the turtle one step north from its original position and [recursively] invoke the maze of exploration to find the exit from the new position.\n",
                "* :: If the above steps do not find an exit, then move the turtle one step south from its original position and call Explore Maze [recursively] from the new position.\n",
                "* :: If no exit can be found to the south, move the turtle one step west from its original position and call Explore Maze [recursively] from the new position.\n",
                "* :: If no exit can be found to the west, move the turtle one step east from its original position and call Explore Maze [recursively] from the new position.\n",
                "* If you can't find an exit in any of the four directions above, then there's no exit from this maze. *"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "But:\n",
                "* :: If we move the turtle in a certain direction (e.g., north), and if north of the new position happens to be a wall, then a recursive call at the new position will cause the turtle to try to go south\n",
                "* ♪ But one square south of the new position, exactly where it was before the recursive call ♪\n",
                "\n",
                "$\\implies$ and you're stuck in an infinite recursive loop.\n",
                "\n",
                "The $\\implies$ breadcrumb mechanism (recording the paths taken by turtles)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "That is: sprinkle \"breadcrumbs\" along the way.\n",
                "* :: Stop stepping on \"breadcrumbs\" as soon as you see them in your direction of travel\n",
                "* :: Instead, it must be tried in the next direction\n",
                "\n",
                "$\\implies$ for a recursive call, that is, if a \"breadcrumb\" is found on a square in a certain direction, it immediately returns to the previous level from the recursive call."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The \"basic end condition\" for optimizing recursive calls is as follows.\n",
                "* :: Turtle hits \"wall\" square, recursive call ends, return failure\n",
                "* :: Turtle touches the \"breadcrumbs\" box, indicating that this box has been visited, recursive call ends, return failure\n",
                "* :: Turtle fails to explore in all four directions, recursive call ends, return failure\n",
                "* :: Turtle touches the \"exit\" square, i.e., the \"channel at the edge\" square, recursive call ends, return successful\n",
                "\n",
                "\n",
                "The theory is complete and the realization begins!"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "def searchFrom(maze, startRow, startColumn):\n",
                "    # Boundary checks\n",
                "    if (startRow < 0 or startRow >= maze.rows or \n",
                "        startColumn < 0 or startColumn >= maze.columns):\n",
                "        return False\n",
                "    \n",
                "    maze.updatePosition(startRow, startColumn)\n",
                "    \n",
                "    # 1. Encountering obstacles\n",
                "    if maze[startRow][startColumn] == OBSTACLE:\n",
                "        return False\n",
                "    # 2. Tried and true or dead ends\n",
                "    if (maze[startRow][startColumn] == TRIED or \n",
                "        maze[startRow][startColumn] == DEAD_END):\n",
                "        return False\n",
                "    # 3. Finding an exit\n",
                "    if maze.isExit(startRow, startColumn):\n",
                "        maze.updatePosition(startRow, startColumn, PART_OF_PATH)\n",
                "        return True\n",
                "    \n",
                "    # 4. Marked for attempted routing\n",
                "    maze.updatePosition(startRow, startColumn, TRIED)\n",
                "    \n",
                "    # Explore in the order North → West → South → East (use brackets instead of backslashes)\n",
                "    found = (\n",
                "        searchFrom(maze, startRow - 1, startColumn) # 北\n",
                "        or searchFrom(maze, startRow, startColumn - 1) # 西\n",
                "        or searchFrom(maze, startRow + 1, startColumn) # 南\n",
                "        or searchFrom(maze, startRow, startColumn + 1) # 东\n",
                "    )\n",
                "    \n",
                "    # Backtracking markers\n",
                "    if found:\n",
                "        maze.updatePosition(startRow, startColumn, PART_OF_PATH)\n",
                "    else:\n",
                "        maze.updatePosition(startRow, startColumn, DEAD_END)\n",
                "        \n",
                "    return found"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 2,
            "metadata": {},
            "outputs": [],
            "source": [
                "def searchFrom(maze, startRow, startCol):\n",
                "    # Boundary checks\n",
                "    if (startRow < 0 or startRow >= maze.rows or \n",
                "        startCol < 0 or startCol >= maze.columns):\n",
                "        return False\n",
                "\n",
                "    # Obstacles encountered or paths explored\n",
                "    if maze[startRow][startCol] == OBSTACLE or \\\n",
                "       maze[startRow][startCol] in (TRIED, DEAD_END):\n",
                "        return False\n",
                "\n",
                "    # Exit found (must be a boundary space)\n",
                "    if maze.isExit(startRow, startCol):\n",
                "        maze.updatePosition(startRow, startCol, PART_OF_PATH)\n",
                "        return True\n",
                "\n",
                "    # Mark the current path to try\n",
                "    maze.updatePosition(startRow, startCol, TRIED)\n",
                "\n",
                "    # Explore in the order North → West → South → East\n",
                "    found = (\n",
                "        searchFrom(maze, startRow-1, startCol) or # 北\n",
                "        searchFrom(maze, startRow, startCol-1) or # 西\n",
                "        searchFrom(maze, startRow+1, startCol) or # 南\n",
                "        searchFrom(maze, startRow, startCol+1) # 东\n",
                "    )\n",
                "\n",
                "    # Backtracking to mark the final path or dead end\n",
                "    maze.updatePosition(startRow, startCol, \n",
                "                       PART_OF_PATH if found else DEAD_END)\n",
                "    return found"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 3,
            "metadata": {},
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "+++++++++++++\n",
                        "+-----------+\n",
                        "+-++++++++-++\n",
                        "+-+-------+ +\n",
                        "+-+-+++-+-+ +\n",
                        "+---+---+-+ +\n",
                        "+++++-+++++ +\n",
                        "+-----+     +\n",
                        "+++++++++++++\n"
                    ]
                }
            ],
            "source": [
                "maze = Maze(\"maze.txt\")\n",
                "searchFrom(maze, maze.startRow, maze.startCol)\n",
                "\n",
                "# Print the final path result\n",
                "for row in maze.mazelist:\n",
                "    print(''.join(row))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 1,
            "metadata": {},
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "-\n"
                    ]
                }
            ],
            "source": [
                "import turtle\n",
                "import time\n",
                "\n",
                "# Symbolic constants\n",
                "OBSTACLE = '+'\n",
                "TRIED = '.'\n",
                "DEAD_END = '-'\n",
                "PART_OF_PATH = 'O'\n",
                "\n",
                "class Maze:\n",
                "    def __init__(self, mazeFileName):\n",
                "        self.t = turtle.Turtle()\n",
                "        self.t.speed(0)\n",
                "        self.t.hideturtle()\n",
                "        self.screen = turtle.Screen()\n",
                "        self.screen.setup(800, 600)\n",
                "        self.screen.tracer(0)\n",
                "        \n",
                "        with open(mazeFileName, 'r') as f:\n",
                "            self.mazelist = []\n",
                "            for row, line in enumerate(f.read().splitlines()):\n",
                "                row_data = []\n",
                "                for col, ch in enumerate(line):\n",
                "                    row_data.append(ch)\n",
                "                    if ch == 'S':\n",
                "                        self.startRow, self.startCol = row, col\n",
                "                self.mazelist.append(row_data)\n",
                "        \n",
                "        self.rows = len(self.mazelist)\n",
                "        self.columns = len(self.mazelist[0]) if self.rows > 0 else 0\n",
                "        self.cell_size = 20\n",
                "        self._draw_maze()\n",
                "\n",
                "    def _draw_maze(self):\n",
                "        self.t.penup()\n",
                "        for y in range(self.rows):\n",
                "            for x in range(self.columns):\n",
                "                screen_x = -self.columns*self.cell_size/2 + x*self.cell_size\n",
                "                screen_y = self.rows*self.cell_size/2 - y*self.cell_size\n",
                "                \n",
                "                if self.mazelist[y][x] == OBSTACLE:\n",
                "                    self.t.goto(screen_x, screen_y)\n",
                "                    self.t.color('blue')\n",
                "                    self.t.dot(self.cell_size-2)\n",
                "                elif self.mazelist[y][x] == 'S':\n",
                "                    self.t.goto(screen_x, screen_y)\n",
                "                    self.t.color('orange')\n",
                "                    self.t.dot(self.cell_size-2)\n",
                "                elif self.mazelist[y][x] == 'E':\n",
                "                    self.t.goto(screen_x, screen_y)\n",
                "                    self.t.color('purple')\n",
                "                    self.t.dot(self.cell_size-2)\n",
                "\n",
                "    def __getitem__(self, index):\n",
                "        return self.mazelist[index]\n",
                "\n",
                "    def isExit(self, row, col):\n",
                "        return (row == 0 or row == self.rows-1 or \n",
                "                col == 0 or col == self.columns-1) and self.mazelist[row][col] == ' '\n",
                "\n",
                "    def updatePosition(self, row, col, status=None):\n",
                "        if status:\n",
                "            self.mazelist[row][col] = status\n",
                "            \n",
                "            screen_x = -self.columns*self.cell_size/2 + col*self.cell_size\n",
                "            screen_y = self.rows*self.cell_size/2 - row*self.cell_size\n",
                "            self.t.goto(screen_x, screen_y)\n",
                "            \n",
                "            if status == TRIED:\n",
                "                self.t.color('gray')\n",
                "            elif status == DEAD_END:\n",
                "                self.t.color('red')\n",
                "            elif status == PART_OF_PATH:\n",
                "                self.t.color('green')\n",
                "            \n",
                "            self.t.dot(self.cell_size-2)\n",
                "            self.screen.update()\n",
                "            time.sleep(0.05)\n",
                "\n",
                "def searchFrom(maze, startRow, startCol):\n",
                "    if (startRow < 0 or startRow >= maze.rows or \n",
                "        startCol < 0 or startCol >= maze.columns):\n",
                "        return False\n",
                "\n",
                "    if maze[startRow][startCol] == OBSTACLE or \\\n",
                "       maze[startRow][startCol] in (TRIED, DEAD_END):\n",
                "        return False\n",
                "\n",
                "    if maze.isExit(startRow, startCol):\n",
                "        maze.updatePosition(startRow, startCol, PART_OF_PATH)\n",
                "        return True\n",
                "\n",
                "    maze.updatePosition(startRow, startCol, TRIED)\n",
                "\n",
                "    found = (searchFrom(maze, startRow-1, startCol) or\n",
                "             searchFrom(maze, startRow, startCol-1) or\n",
                "             searchFrom(maze, startRow+1, startCol) or\n",
                "             searchFrom(maze, startRow, startCol+1))\n",
                "\n",
                "    maze.updatePosition(startRow, startCol, \n",
                "                       PART_OF_PATH if found else DEAD_END)\n",
                "    return found\n",
                "\n",
                "# Examples of use\n",
                "maze = Maze(\"maze.txt\")\n",
                "searchFrom(maze, maze.startRow, maze.startCol)\n",
                "# View starting point status at final print\n",
                "print(maze[maze.startRow][maze.startCol]) # should output 'O' (valid path)\n",
                "turtle.done()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Note that this one goes back to the beginning. Because:\n",
                "* :: The inevitable path of recursive backtracking\n",
                "* :: Recursive algorithms backtrack along the call stack and mark valid paths when they find an exit\n",
                "* :: The starting point, as the first recursive call point, is necessarily the end point of the path marker"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "This algorithm can be used to schedule the motion trajectory of the sweeping robot"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "********************************************************************\n",
                "# <a id='toc8_'></a> [Assignment](#toc0_)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#homework1\n",
                "# m to decimal\n",
                "def c_m_10(num, m):\n",
                "    # 公式 num = an * m**(n-1) + an-1 * m**(n-2).....+ a0 * m**0\n",
                "    # Utilize int's own functions directly\n",
                "    num = int(str(num), base=m)\n",
                "    return num\n",
                " \n",
                "# Decimal to m-decimal\n",
                "def c_10_m(num, n):\n",
                "    res = \"\"\n",
                "    while num:\n",
                "        res = \"0123456789ABCDEFGHIGKLMNOPQRSTUVWXYZ\"[num % n] + res\n",
                "        num = num // n\n",
                "    return res\n",
                "# m-binary to n-binary\n",
                "def m_10_n(num, m, n):\n",
                "    return c_10_m(c_m_10(num, m), n)\n",
                " \n",
                "m, n = map(int, input().split())\n",
                "num = input()\n",
                "print(m_10_n(num, m, n))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#homework2\n",
                "def hanoi4(n):\n",
                "    h_list = [0] * (n + 1)\n",
                " \n",
                "    def f(m):\n",
                "        if h_list[m]:#when h_list[m] = 1.because there is only one time for 1 pan.\n",
                "            return h_list[m]\n",
                "        result = 2 ** m - 1#3 hanoi\n",
                "        for x in range(1, m):\n",
                "            result = min(result, 2 * f(x) + 2 ** (m - x) - 1)#record the times when #pans <= m.x less than m for 37th row is calculating.\n",
                "        h_list[m] = result\n",
                "        return result\n",
                " \n",
                "    return f(n)\n",
                "print(hanoi4(int(input())))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# homework3\n",
                "def carpet(N, C):\n",
                "    def check(n, x, y):\n",
                "        if n <= 1:\n",
                "            return True\n",
                "        n2 = n // 3\n",
                "        if n2 <= x < n2 * 2 and n2 <= y < n2 * 2:\n",
                "            return False\n",
                "        return check(n2, x%n2, y%n2)\n",
                " \n",
                "    for y in range(N):\n",
                "        for x in range(N):\n",
                "            if check(N, x, y):\n",
                "                print(C, end='')\n",
                "            else:\n",
                "                print(' ' * len(C), end='')\n",
                "        print('')\n",
                " \n",
                "N = int(input())\n",
                "C = input()\n",
                "carpet(N,C)"
            ]
        }
    ],
    "metadata": {
        "kernelspec": {
            "display_name": "base",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.12.7"
        },
        "orig_nbformat": 2
    },
    "nbformat": 4,
    "nbformat_minor": 2
}