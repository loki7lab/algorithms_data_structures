{
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "[Thought for the week]\n",
                "  The linear structure journey continues this week with a study of queues and their applications and extensions. After learning about lists, hand rubbing chained tables to implement unordered and ordered tables and summarizing linear structures is described below:\n",
                "  * :: 308 queue ADT and python implementation\n",
                "  * :: 309 Queue application: hot potatoes\n",
                "  * :: 310-311 Application of queues: print jobs [this is difficult and is a simulation problem]\n",
                "  * :: 312 Combining the characteristics of queues and stacks to present a double-ended queue ADT with python implementation and practical examples\n",
                "\n",
                "I was using lists before, but now I'm going up in intensity and hand rubbing chain lists:\n",
                "  * :: 313-314 Implementation of an unordered table ADT based on a linked table\n",
                "  * :: 315 Implementation of ordered table ADT based on chained tables\n",
                "\n",
                "Final Summary:\n",
                "  * :: 316 Linear structure summary"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "**Table of contents**<a id='toc0_'></a>    \n",
                "- [308 Queue ADT and python implementation](#toc1_)\n",
                "  - [1. 什么是队列【first in first out】](#toc1_1_)\n",
                "  - [2. Queue ADT] (#toc1_2_)\n",
                "  - [3. python implementation of Queue ADT](#toc1_3_)\n",
                "- [309 Applications of queues: hot potato problem] (#toc2_)\n",
                "  - [1. Title] (#toc2_1_)\n",
                "  - [2. Algorithms] (#toc2_2_)\n",
                "- [310 Application of Queues: Printing Tasks [Analyze and Model] (#toc3_)\n",
                "  - [1. Title] (#toc3_1_)\n",
                "  - [2. Prior knowledge] (#toc3_2_)\n",
                "- [311 Application of Queues: Printing Tasks [Practical Implementation]](#toc4_)\n",
                "  - [1. Algorithms] (#toc4_1_)\n",
                "- [312 Double-ended queue deque abstract data type](#toc5_)\n",
                "  - [Deque ADT](#toc5_1_)    \n",
                "  - [Operational definition of double-ended queue](#toc5_2_)\n",
                "  - [Double-ended queue case - palindrome determination](#toc5_3_)\n",
                "- [313 Unordered Table Abstract Data Structures [Hand-Rubbed Chained Storage List/Irregular to Native List]](#toc6_)\n",
                "- [314 Chain table implementation: unordered table](#toc7_)\n",
                "- [Implementation of abstract data types for ordered tables](#toc8_)\n",
                "\n",
                "<!-- vscode-jupyter-toc-config\n",
                "numbering=false\n",
                "anchor=true\n",
                "flat=false\n",
                "minLevel=1\n",
                "maxLevel=6\n",
                "/vscode-jupyter-toc-config -->\n",
                "<!-- THIS CELL WILL BE REPLACED ON TOC UPDATE. DO NOT WRITE YOUR TEXT IN THIS CELL -->"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc1_'></a>[308 Queue ADT and python implementation](#toc0_)\n",
                "\n",
                "## <a id='toc1_1_'></a>[1. 什么是队列【first in first out】](#toc0_)\n",
                "* :: An ordered collection of data\n",
                "* :: Characterized by:** First In First Out**\n",
                "* :: One entrance and exit only\n",
                "\n",
                "Use cases are:\n",
                "* :: Print queue: one printer serves multiple users/programs\n",
                "* :: Process scheduling: the core of the operating system uses multiple queues to schedule simultaneously running processes in the system. The scheduling principle combines 2 starting points\n",
                "    * :: First-come, first-served\n",
                "    * :: Full utilization of resources\n",
                "* :: Keyboard buffer: Keystrokes are not immediately displayed on the screen, but there is a queue of buffers in which the characters that have not yet been displayed are stored."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc1_2_'></a>[2. Queue ADT](#toc0_)\n",
                "Queue-based structural characterization needs to be implemented:\n",
                "* :: Data items are added to the tail-rear end only\n",
                "* :: Data items are removed from the first front only\n",
                "\n",
                "$\\implies$ FIFO\n",
                "\n",
                "Refined operational definitions are available:\n",
                "* :: Queue(): create an empty queue object, the return value is a Queue object;\n",
                "* :: enqueue(item): add data item to the end of the queue, no return value;\n",
                "* :: dequeue(): removes the data item from the head of the queue, the return value is the head of the queue data item and the queue is modified;\n",
                "* :: isEmpty(): test whether the queue is empty, the return value is a boolean value\n",
                "* :: size(): returns the number of data items in the queue\n",
                "\n",
                "Hint: still using list to create queue ADT"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc1_3_'></a>[3. python implementation of Queue Queue ADT](#toc0_)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class Queue:\n",
                "    def __init__(self):\n",
                "        self.items = []\n",
                "    def enqueue(self,item):\n",
                "        self.items.append(item)#复杂度O(1)\n",
                "    def dequeue(self):\n",
                "        return self.items.pop(0)#复杂度O(n)\n",
                "    def isEmpty(self):\n",
                "        return self.items == []\n",
                "    def size(self):\n",
                "        return len(self.items)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# In reverse, the complexity of entering and exiting the queue is swapped. Unlike a stack, a stack doesn't pick which one to head, and the complexity can be high\n",
                "class Queue:\n",
                "    def __init__(self):\n",
                "        self.items = []\n",
                "    def isEmpty(self):\n",
                "        return len(self.items) == 0\n",
                "    def size(self):\n",
                "        return len(self.items)\n",
                "    def enqueue(self,item):\n",
                "        self.items.insert(0,item)\n",
                "    def dequeue(self):\n",
                "        return self.items.pop()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc2_'></a>[309 Application of queues: the hot potato problem](#toc0_)\n",
                "## <a id='toc2_1_'></a> [1. title](#toc0_)\n",
                "Came to an amazing problem. There are now 40 people who need to report from number 1 to 7, and those who report to 7 are killed by the person next to them. After the last person has chimed in for the round, the next person chimes in again from number 1. In order to survive, how many initial bits should be chosen?\n",
                "\n",
                "That's a bloody good problem to have, the normaler version is the hot potato problem."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc2_2_'></a> [2. Algorithm](#toc0_)\n",
                "* :: Use of queues to implement simulated hot potato delivery\n",
                "* :: List of names of people who need to participate in the game and the number of times the potatoes were passed num\n",
                "* :: Return the name of the last remaining person"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "<img src=\"./img/hotpo.PNG\">"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Further refinement, there:\n",
                "* :: Use of a queue to store all players\n",
                "* :: Passing potatoes from the head of the queue to the tail of the queue in the same direction as they were passed\n",
                "* The team leader is the one who holds the potatoes\n",
                "* :: The leader of the group is constantly out of the group and then in from the end of the group\n",
                "\n",
                "$\\implies$ After passing num times, the person at the head of the queue is out of the queue and will not enter again.\n",
                "\n",
                "Repeat until there is only 1 person left in the queue\n",
                "\n",
                "The point is:\n",
                "* :: Use of loops\n",
                "* Whoever calls that number is out of the line\n",
                "* :: Computers start at 0, shouting numbers starts at 1"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "from pythonds.basic.queue import Queue\n",
                "def hotPotato(namlist,num):\n",
                "    simqueue = Queue()\n",
                "    for name in namlist:\n",
                "        simqueue.enqueue(name)#先排队\n",
                "    \n",
                "    while simqueue.size() > 1:\n",
                "        for i in range(num):#1 to num personally resolved\n",
                "            simqueue.enqueue(simqueue.dequeue())\n",
                "        simqueue.dequeue()\n",
                "    \n",
                "    return simqueue.dequeue()#return who is left at last"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "namelist = list(range(40))\n",
                "print(hotPotato(namelist,7))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "However, there is a small problem here, when debugging using the example below, the first popup is david, while the correct one is bill, because the python table starts from 0, while the counting starts from 1."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(hotPotato([\"bill\",\"david\",\"susan\",\"jane\",\"kent\",\"brad\"],7))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# May be improved as follows\n",
                "from pythonds.basic.queue import Queue\n",
                "def hotPotato(namlist,num):\n",
                "    simqueue = Queue()\n",
                "    for name in namlist:\n",
                "        simqueue.enqueue(name)# queue first; 6 people here then, it is from number 0 to number 5\n",
                "    \n",
                "    while simqueue.size() > 1:\n",
                "        for i in range(num-1):#this 0 to num-2 people kept, total num-1 people; num can be larger than namlist size\n",
                "            simqueue.enqueue(simqueue.dequeue())#出队入队\n",
                "        print(simqueue.dequeue())# pop the person labeled num-1, which is actually shouting num, so that he or she will never be in the queue\n",
                "    \n",
                "    return simqueue.dequeue()#return who is left at last\n",
                "\n",
                "print(hotPotato([\"bill\",\"david\",\"susan\",\"jane\",\"kent\",\"brad\"],7))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "namelist = list(range(40))\n",
                "print(hotPotato(namelist,7))#Note that the actual number shouted needs to be +1 on top of the printed number"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "So the code test case is \"41 people, the person who shouted 3 died\", the last survivor is 16 and 31 are in line with the position"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc3_'></a>[310 Application of Queues: Printing Tasks [Analyze and Model]](#toc0_)\n",
                "\n",
                "## <a id='toc3_1_'></a> [1. title](#toc0_)\n",
                "Multiple people share a printer, and a \"first-come, first-served\" queuing policy is used to execute print jobs. In this setup, the prerequisites to be determined are:\n",
                "1. What is the capacity of this print job system?\n",
                "2. How many users and how many print jobs can the system accommodate and at what frequency within an acceptable waiting time?\n",
                "\n",
                "The performance of the printer is:\n",
                "* :: Draft mode, 10 pages per minute\n",
                "* :: Normal mode, 5 pages per minute\n",
                "\n",
                "After identifying, list the questions:\n",
                "\n",
                "$\\implies$ How do I set the printer mode to maximize print quality without everyone waiting too long?\n",
                "\n",
                "This is a typical decision support problem, but it cannot be computed directly by rules.\n",
                "\n",
                "$\\implies$ A program can be used to simulate this scenario and then analyze the results to support decisions on printer mode settings."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc3_2_'></a>[2. Prior knowledge](#toc0_)\n",
                "To solve it algorithmically, you first need to model the problem by abstracting its objects and processes:\n",
                "\n",
                "* Objects?\n",
                "    * :: Attributes of print jobs: submission time, number of pages printed [class creation required]\n",
                "    * :: Properties of print queue: print job queue with FIFO properties [this is a queue]\n",
                "    * :: Printer attributes: print speed, busy or not [class creation required]\n",
                "\n",
                "* Process?\n",
                "    1. The process of generating and submitting print jobs:\n",
                "       * :: Determine the probability of generation: e.g., how often a job will be generated\n",
                "       * :: Determine the number of pages to be printed: examples are up to 20 pages and may be set to equal probability\n",
                "    2. Specific implementation of the printing process:\n",
                "       * :: Current print jobs\n",
                "       * :: End-of-print countdown: the countdown starts when a new job starts to print. A return of 0 indicates that printing is complete and the next job can be processed.\n",
                "\n",
                "* :: Time frame?\n",
                "    * :: This is for a unified simulation world\n",
                "    * :: Harmonized time frames: uniform passage in minimum units of seconds, with a maximum simulation time set to look at, for example, a 1-hour period\n",
                "    * :: Synchronization of all processes: generation of print jobs and implementation of printing are performed once in a unit of time"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc4_'></a>[311 Application of Queues: Printing Tasks [Practical Implementation]](#toc0_)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc4_1_'></a> [1. Algorithm](#toc0_)\n",
                "Note that this algorithm is designed to simulate the process\n",
                "1. Create a print queue object\n",
                "2. Simulation of the passage of time in seconds\n",
                "3. Exhaustion of time and commencement of statistics on average waiting time\n",
                "\n",
                "How do I calculate the time?\n",
                "* :: Waiting time for assignments:\n",
                "    * :: Record corresponding time stamps when generating jobs\n",
                "    * :: When printing starts, the current time minus the generation time is sufficient\n",
                "* :: Job printing time:\n",
                "    * :: When generating assignments, record the number of pages of the assignment\n",
                "    * :: Start printing by dividing the number of pages by speed"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Further refining step 2, there are\n",
                "* :: Probabilistic generation of print jobs to be added to the print queue\n",
                "* :: If the printer is idle and the queue is not empty, take out the head of the queue and print the job\n",
                "* If the printer is busy, it prints at the print speed.\n",
                "* :: If the current job print is complete, the printer enters an idle state\n",
                "\n",
                "$\\implies$ Please note that the printer class also needs to add a countdown timer"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "To summarize, the simulation task needs to be simulated as follows:\n",
                "* :: Printers have their own characteristics, such as print speeds\n",
                "* :: Print jobs are organized in queues\n",
                "* :: Can determine whether it is busy or not; if not, it is taken out of the queue\n",
                "* :: Timing required: time spent printing, time spent waiting, and total time spent\n",
                "\n",
                "Referring to the course content, you may wish to split and write classes and functions:\n",
                "* :: Printer class\n",
                "* :: Classes of a mandatory nature\n",
                "\n",
                "Generate the function:\n",
                "* :: Whether to generate mandates\n",
                "* :: Analog simulation (aggregate function)\n",
                "\n",
                "For simplicity's sake, faithfully describe what's going on every second: whether a new task is being generated, whether a new task is being accepted, and whether it's printing. Otherwise it's not easy to write\n",
                "\n",
                "Conceptualization is complete and implementation begins!"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Write down what to call first\n",
                "\n",
                "from pythonds.basic.queue import Queue\n",
                "import random\n",
                "for i in range(10):\n",
                "    simulation(3600,5)#Printer prints 5 pages per minute, simulated in 3600 seconds\n",
                "# Need to have the probability of generating a job, the number of pages in the job, and be able to calculate the waiting time required for this (not necessarily printing the job immediately after it is generated, but also seeing if the printer is busy)\n",
                "# The point is to simulate the passage of time, to show it by the second #"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#Writing frameworks\n",
                "\n",
                "def simulation(numSeconds,pagesPerMinute):\n",
                "    labPrinter = Printer(pagesPerMinute)# Here the printer class is not yet written, take the place first\n",
                "    printerQueue = Queue()\n",
                "    waitingTimes = []#计时\n",
                "\n",
                "    for currentSecond in range(numSeconds):# all 3 items are parallelized within this 1 second period\n",
                "# Refer to refinement step 2 above\n",
                "        if newPrintTask():# a new task has been generated; this can be done using a function, not a class\n",
                "            task = Task(currentSecond)#Task to have; add random function, otherwise the number of pages won't change; also be able to add timestamps\n",
                "            printerQueue.enqueue(task)#入队\n",
                "       \n",
                "        #Take it if the printer is not busy and the queue is not empty.\n",
                "        if (not labPrinter.busy()) and (not printerQueue.isEmpty()):#打印机类要有busy的判断\n",
                "            nextTask = printerQueue.dequeue()\n",
                "            #Time it with the list again\n",
                "            waitingTimes.append(nextTask.waitingTimes(currentSecond)) #Task class to have; note how long it waited before starting to print\n",
                "\n",
                "            labPrinter.startNext(nextTask)# printer class to have; start new task; this is going to involve two classes\n",
                "        \n",
                "        #Write it here so that new assignments can begin too\n",
                "        # This 1 second of printing\n",
                "        labPrinter.tick()# printer class to have; simulate 1 second\n",
                "\n",
                "    # Simulation time expires, calculate wait time\n",
                "    averageWait = sum(waitingTimes)/len(waitingTimes)#总时间/总任务数\n",
                "    print(\"Average Wait %6.2f secs %3d tasks remaining.\" %(averageWait,printerQueue.size()))#看剩了多少没干完"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Write the classes needed for the task based on the framework's instance task and the nextTask out of the printerQueue\n",
                "class Task:\n",
                "    def __init__(self,time):\n",
                "        self.timestamp = time\n",
                "        self.pages = random.randrange(1,21)\n",
                "    def getStamp(self):\n",
                "        return self.timestamp\n",
                "    def getPages(self):\n",
                "        return self.pages\n",
                "    def waitTimes(self,currentTime):\n",
                "        return currentTime - self.timestamp\n",
                "    \n",
                "########################################\n",
                "\n",
                "def newPrintTask():\n",
                "    npt = random.randrange(0,181)\n",
                "    if npt == 100:# Just pick a random number.\n",
                "        return True\n",
                "    else:\n",
                "        return False"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Write the printer class based on the framework's example labPrinter\n",
                "class Printer:\n",
                "    def __init__(self,ppm):\n",
                "        self.pageRate = ppm\n",
                "        self.currentTask = None\n",
                "        self.timeRemaining = 0\n",
                "\n",
                "    def busy(self):\n",
                "        if self.currentTask != None:\n",
                "            return True\n",
                "        else:\n",
                "            return False\n",
                "        \n",
                "    def startNext(self,newTask):#newTask来自Task类\n",
                "        self.currentTask = newTask#Look at how the printer property is defined above.\n",
                "        self.timeRemaining = newTask.getPages()/self.pageRate * 60#任务计时\n",
                "\n",
                "    \n",
                "    def tick(self):\n",
                "        if self.currentTask != None:\n",
                "            self.timeRemaining -= 1\n",
                "            if self.timeRemaining <= 0:\n",
                "                self.currentTask = None"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "from pythonds.basic.queue import Queue\n",
                "import random\n",
                "for i in range(10):\n",
                "    simulation(3600,10)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Compare the two scenarios, analyze the simulation results and further discuss there:\n",
                "* :: Decisions on print mode settings can be made and job wait times can be evaluated using a simulation program\n",
                "* :: Simulation systems are useful for the simulation of reality:\n",
                "    * :: Simulations can be repeated many times with different settings to aid decision-making without depleting real-world resources\n",
                "* :: The print job simulation program can be enriched with different settings for richer simulations (improvement of simulation experiments)\n",
                "* :: More realistic simulations, resulting from finer modeling of the problem and setting up and running with real data\n",
                "* :: Can also be extended to other similar decision support issues"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The code in this case is subtle and can be learned many times over"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc5_'></a>[312 Double-ended queue deque abstract data type](#toc0_)\n",
                "\n",
                "## <a id='toc5_1_'></a>[Deque ADT](#toc0_)\n",
                "Now **integrate the characteristics of queues and stacks** and deduce double-ended queues:\n",
                "* :: Data items can be added or removed from both ends\n",
                "* Can be used to simulate a stack or queue\n",
                "* :: But double-ended queues do not have inherent FIFO or FILO characteristics themselves\n",
                "* :: Requires users to maintain operational consistency"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc5_2_'></a>[Operational definition of double-ended queue](#toc0_)\n",
                "The operation of dequeue is defined as follows\n",
                "* :: Deque(): create an empty double-ended queue\n",
                "* :: addFront(item): add item to the front of the queue\n",
                "* :: addRear(item): add item to the end of the queue\n",
                "* :: removeFront(): remove the data item from the head of the queue, the return value is the removed data item\n",
                "* :: removeRear(): remove the data item from the end of the queue, the return value is the removed data item\n",
                "* :: isEmpty(): return whether the deque is empty or not\n",
                "* :: size(): returns the number of data items contained in the deque\n",
                "\n",
                "Implemented using List, List[-1] is the first end of the deque\n",
                "\n",
                "Idea complete, start realizing"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class Deque:\n",
                "    def __init__(self):\n",
                "        self.items = []\n",
                "    \n",
                "    def addFront(self,item):#O(1)\n",
                "        self.items.append(item)\n",
                "    \n",
                "    def removeFront(self):#O(1)\n",
                "        return self.items.pop()\n",
                "\n",
                "    def addRear(self,item):#O(n)\n",
                "        self.items.insert(0,item)\n",
                "    \n",
                "    def removeRear(self):#O(n)\n",
                "        return self.items.pop(0)\n",
                "    \n",
                "    def isEmpty(self):\n",
                "        return self.items == []\n",
                "    def size(self):\n",
                "        return len(self.items)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## <a id='toc5_3_'></a>[Double-ended queue case - palindrome determination](#toc0_)\n",
                "\n",
                "Palindromes are words that read the same both forwards and backwards, e.g. radar, shandong falling peanut flower falling east mountain\n",
                "\n",
                "Algorithm:\n",
                "\n",
                "1. Add the word to be determined to the deque from the end of the queue.\n",
                "2. Remove characters from both ends simultaneously to determine if they are the same, until the final deque is left with 0 or 1 character.\n",
                "\n",
                "Idea complete, start realizing"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#from pythonds.basic.deque import Deque\n",
                "def palchecker(aString):\n",
                "    chardeque = Deque()\n",
                "    for ch in aString:\n",
                "        chardeque.addRear(ch)\n",
                "    stillEqual = True\n",
                "    while chardeque.size() > 1 and stillEqual:\n",
                "        first = chardeque.removeFront()\n",
                "        last = chardeque.removeRear()\n",
                "        stillEqual = (first == last)\n",
                "    return stillEqual"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(palchecker(\"lsdkjfskf\"))\n",
                "print(palchecker(\"radar\"))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "from pythonds.basic.deque import Deque\n",
                "def palchecker(aString):\n",
                "    chardeque = Deque()\n",
                "    for ch in aString:\n",
                "        chardeque.addRear(ch)\n",
                "    stillEqual = True\n",
                "    \n",
                "    while chardeque.size() > 1 and stillEqual:\n",
                "        first = chardeque.removeFront()\n",
                "        last = chardeque.removeRear()\n",
                "        \n",
                "        if first != last:\n",
                "            stillEqual = False\n",
                "    return stillEqual\n",
                "    \n",
                "print(palchecker(\"lsdkjfskf\"))\n",
                "print(palchecker(\"radar\"))"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc6_'></a>[313 Node class implementation in ADT for unordered tables [hand-rubbed chain-stored List/iso native List]](#toc0_)\n",
                "1. List List is a simple and powerful dataset structure that provides a rich interface for operations. However, not all programming languages provide the List datatype, and sometimes programmers need to implement it themselves.\n",
                "2. What is a list, or unordered table?\n",
                "* :: Is a data set in which data items are stored in relative positions\n",
                "* :: In particular, it is called an \"unordered list\", in which data items are indexed only according to where they are stored, e.g., first, second ......, last, etc."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Think about the operations that need to be implemented for the unordered table List as follows:\n",
                "* :: ``List()``: creates an empty list\n",
                "* :: ```add(item)``: adds a data item to the list, assuming that item did not already exist in the list.\n",
                "* :: ```remove(item)``: removes the item from the list, the list is modified and the item should have existed in the table.\n",
                "* :: ```search(item)``: finds item in a list, returns a boolean value\n",
                "* :: ```isEmpty()``: Returns whether the list is empty.\n",
                "* :: ```size()``: returns how much data the list contains.\n",
                "\n",
                "How is $\\implies$ realized?\n",
                "\n",
                " In order to realize an unordered table data structure, a scheme implemented as a chained list can be used: $\\implies$ [different from the native List].\n",
                "\n",
                "* :: Although the list data structure requires that the relative position of data items be maintained, such maintenance does not require that the data items be stored sequentially in contiguous storage space\n",
                "* :: There is no rule as to where data items are stored, but if **links are established between data items pointing to **, their relative positions before and after can be maintained [form chains]\n",
                "\n",
                "**It's important **\n",
                "\n",
                "The first and last data items need to be **explicitly** labeled, one at the head of the queue (HEAD is not labeled with the first one) and one at the end of the queue (END is labeled with the last data), with no more data following.\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "<img src = \"./img/313.PNG\">"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "<img src = \"./img/3132.PNG\">"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "This diagram can be quite apt. Unordered table mylist object itself contains the head is only the first node of the chain table Node [reference, does not contain data items]. But from the head of this reference to lead out of a long chain table. Inside these nodes are the data items.\n",
                "\n",
                "To further refine the specific implementation, that is, to build the dataset using linked node Node to implement the unordered table\n",
                "* :: The most basic element of a linked table implementation is the node Node\n",
                "* :: Each node must contain at least 2 pieces of information: the data item itself, and the **reference** information to the next node\n",
                "* :: Note that next is None in the sense that there is no next node [Important!\n",
                "* :: The first and last nodes of a linked table are the most important. If you want to access all the nodes in the chain table, you have to traverse along the next link starting from the first node\n",
                "* So the unordered table must have information about the reference to the first node $\\implies$ to set up a ```attribute head`` that holds the reference to the first node.\n",
                "* :: And as data items are added, the head of the unordered table always points to the first node in the chain\n",
                "\n",
                "\n",
                "$\\implies$ repeat note!\n",
                "\n",
                "* :: The unordered mylist object itself does not contain data items (they are in the nodes), you have to use getData() to see them.\n",
                "* The head contained therein is just a [reference] to the first node Node."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 25,
            "metadata": {},
            "outputs": [],
            "source": [
                "class Node:\n",
                "    def __init__(self,initdata):\n",
                "        self.data = initdata\n",
                "        self.next = None\n",
                "    def getData(self):\n",
                "        return self.data\n",
                "    def getNext(self):\n",
                "        return self.next\n",
                "    def setData(self,newData):\n",
                "        self.data = newData\n",
                "    def setNext(self,newNext):\n",
                "        self.next = newNext"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "temp = Node(93)\n",
                "temp.getData()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "After completing the ADT implementation of node node, the next step is to concatenate the Nodes, that is, to design the unordered table"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc7_'></a>[314 Chained table implementation of unordered tables](#toc0_)\n",
                "Consider exactly how to implement the ADT approach:\n",
                "* add method: where to add can be, but in the head of the table to add [the strongest performance] (because to access to the entire chain of all the data items, must start from the head of the table along the next link one by one to find back). Note: that is, the order of addition is very important\n",
                "Please make sure to handle the order correctly, otherwise the back may be lost and hard to find!"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "<img src=\"./img/1.png\">"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Continue to implement subsequent methods\n",
                "* :: Size method: start from the chain head Head, traverse to the end of the table, while using the variable to accumulate the number of nodes passed through [complexity of O(n)].\n",
                "* :: search method: starting from the head of the chain Head, traversing to the end of the table, while determining whether the current node's data item is the target"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* remove method: find the item first by search, but it is needed for deletion:\n",
                "    * current指向item\n",
                "    * :: Before deleting, you need to point the next node of the previous node to the next node of the current one.\n",
                "  \n",
                "    $\\implies$ requires two pointers so that it can maintain a reference to the previous node\n",
                "\n",
                "Note that there are two situations that may be encountered at remove:\n",
                "* :: current is the first node\n",
                "* :: current is the node in the middle of the chain"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Theory completed, realization begun"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 27,
            "metadata": {},
            "outputs": [],
            "source": [
                "class UnorderedList:\n",
                "    # The harder parts are: initialization, additions and deletions\n",
                "    def __init__(self):\n",
                "        self.head = None#As per the previous section, the unordered table is initialized with head designed to be empty\n",
                "        #This thing is an attribute, but is assigned a reference to the instance (of the)\n",
                "    \n",
                "    def isEmpty(self):\n",
                "        return self.head == None\n",
                "    \n",
                "    def size(self):\n",
                "        count = 0\n",
                "        current = self.head\n",
                "        while current != None:\n",
                "            count += 1\n",
                "            current = current.getNext()# Note the call to the above\n",
                "        return count\n",
                "\n",
                "\n",
                "    def add(self,item):#Add to the very beginning of the\n",
                "        temp = Node(item)# generate node here\n",
                "        temp.setNext(self.head)# points to the first node Node(reference) pointed to by the table head\n",
                "        self.head = temp# point head to a reference to this added node\n",
                "\n",
                "    def search(self,item):\n",
                "        current = self.head\n",
                "        found = False\n",
                "        while current != None and not found:#这里不用getData!\n",
                "            if current.getData() == item:\n",
                "                found = True\n",
                "            else:\n",
                "                current = current.getNext()\n",
                "        return found\n",
                "    \n",
                "    def remove(self,item):\n",
                "        current = self.head\n",
                "        previous = None#注意这里\n",
                "        found = False\n",
                "        while not found:\n",
                "            if current.getData() == item:\n",
                "                found = True\n",
                "            else:\n",
                "                previous = current\n",
                "                current = current.getNext()\n",
                "        if previous == None:# case 1.current is the first node is found\n",
                "            self.head = current.getNext()\n",
                "        else:# Situation 2\n",
                "            previous.setNext(current.getNext())\n",
                "    \n",
                "    def display(self):\n",
                "        elements = []\n",
                "        current = self.head\n",
                "        while current:\n",
                "            elements.append(str(current.getData()))\n",
                "            current = current.getNext()\n",
                "        print(\" -> \".join(elements))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 28,
            "metadata": {},
            "outputs": [],
            "source": [
                "myList = UnorderedList()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Test the isEmpty method\n",
                "print(myList.isEmpty()) # Expected output: True"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 29,
            "metadata": {},
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "Whether the chain is empty after adding an element: False\n"
                    ]
                }
            ],
            "source": [
                "# Test the add method\n",
                "myList.add(31)\n",
                "\n",
                "myList.add(77)\n",
                "\n",
                "myList.add(17)\n",
                "\n",
                "myList.add(93)\n",
                "\n",
                "myList.add(26)\n",
                "\n",
                "myList.add(54)\n",
                "\n",
                "print(f \"Is the chain table empty after adding elements: {myList.isEmpty()}\") # Expected output: Fals"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 30,
            "metadata": {},
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "54 -> 26 -> 93 -> 17 -> 77 -> 31\n",
                        "None\n"
                    ]
                }
            ],
            "source": [
                "print(myList.display())#check that the addition is correct"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Test the size method\n",
                "print(f \"Size of the linked list: {myList.size()}\") # Expected output: 6"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Test the search method\n",
                "\n",
                "print(f \"Finding element 93: {myList.search(93)}\") # Expected output: True\n",
                "\n",
                "print(f \"Find element 100: {myList.search(100)}\") # Expected output: False"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                " # Test the remove method\n",
                "\n",
                "myList.remove(17)\n",
                "\n",
                "print(f \"Size of the linked list after removing element 17: {myList.size()}\") # Expected output: 5\n",
                "\n",
                "print(f \"Finding element 17 after removing element 17: {myList.search(17)}\") # Expected output: False"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The following briefly adds how the ```add()``` first item is implemented:\n",
                "* ```temp = Node(item)``` This line of code creates a new Node object, temp, with the incoming item as the data for that node. At this point, the next attribute of the new node is initialized to None, since it is the only current node and there are no subsequent nodes.\n",
                "* ```temp.setNext(self.head)``` At the initialization of the chain table, self.head is set to None (in the __init__ method). So, this line of code sets the next attribute of the new node temp to None, indicating that there are no other nodes behind that node\n",
                "* ```self.head = temp``` This line of code points the reference self.head to the newly created node temp. self.head now points to the new node, which becomes the first node in the chain table."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "A further explanation of how the second item is added:\n",
                "* ```temp.setNext(self.head)``` When adding a second node, self.head points to the first existing node in the chain table. This line of code sets the next property of the new node, temp, to the head of the chain, which means that the new node points to the original first node.\n",
                "* ```self.head = temp``` Updates the head node of the chain table, self.head, to the newly created node, temp. This makes the new node the new first node of the chain table, and what was the first node is now the second node, since the new node points to it"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "In Python, a property is actually a variable of an object that can store values of various types, including **references to instances**. So head, as a property of the UnorderedList class, is capable of being assigned to an instance. Look at what it looks like, specifically, there:"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Test code\n",
                "if __name__ == \"__main__\":\n",
                "    myList = UnorderedList()\n",
                "    myList.add(31)\n",
                "    myList.add(77)\n",
                "    if myList.head:# when the list is not empty\n",
                "        head_data = myList.head\n",
                "        print(f \"The data type of the head node of the chain table is: {type(head_data)}\")\n",
                "        print(f \"The next in the chain table head node is:{head_data.getNext()}\")\n",
                "    else:\n",
                "        print(\"The chain table is empty, there is no head node data.\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "The latter briefly introduces the doubly linked table, and the related content is omitted for now."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# <a id='toc8_'></a>[315 Implementation of abstract data types for ordered tables](#toc0_)\n",
                "What is an ordered table?\n",
                "* :: Determine position in the list according to some comparable property (e.g., integer size, alphabetical order)\n",
                "\n",
                "Define the operation, there:\n",
                "* :: OrderedList(): creates an empty ordered table\n",
                "* add(item): add a data item in the table, [** and maintain the overall order **], this item does not exist\n",
                "* :: remove(item): removes a data item from an ordered table, this item should exist and the ordered table should be modified.\n",
                "* :: search(item): find a data item in an ordered table, return whether it exists or not\n",
                "* :: isEmpty(): Whether the table is empty or not\n",
                "* :: size(): return the number of data items in the table\n",
                "* :: index(item): returns the position of the data item in the table, this item should exist\n",
                "* :: pop(): removes and returns the last item in an ordered table, of which there should be at least one.\n",
                "* :: pop(pos): removes and returns the data item at the specified position in the ordered table, which should exist."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "<img src=\"./img/315.png\">"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "For simplicity, refer to the unordered table of contents, there:\n",
                "* :: Also implemented using a chained list approach\n",
                "* :: Node definition is the same\n",
                "* :: OrderedList also sets a head to hold references to the head of the linked table.\n",
                "* :: Changes to the search/add method.\n",
                "    * search: the use of chained nodes in an orderly manner, for search to save non-existent data items to find time $ $ \\ implies $ Once the current node of the data item is greater than the data item to be found, you can directly return False\n",
                "    * :: add: It must be ensured that the added data item is in the right place to maintain the orderliness of the whole chain table [compare sizes]."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Note the add method:\n",
                "* :: There is no reference to the predecessor node since it was added before the current node and the linked list is just a single linked table\n",
                "* :: So refer to the remove method for unordered tables and introduce the previous pointer\n",
                "\n",
                "Note that there are also two scenarios:\n",
                "* :: Add the first\n",
                "* :: Insertion in the middle\n",
                "  \n",
                "These two must never be in the wrong order, or the chain table will be destroyed\n",
                "\n",
                "Theory completed, realization begun"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class Node:\n",
                "    def __init__(self,initData):\n",
                "        self.data = initData\n",
                "        self.next = None\n",
                "    def getData(self):\n",
                "        return self.data\n",
                "    def getNext(self):\n",
                "        return self.next\n",
                "    def setData(self,newData):\n",
                "        self.data = newData\n",
                "    def setNext(self,newNext):\n",
                "        self.next = newNext"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "class OrderedList:\n",
                "    \n",
                "    def __init__(self):\n",
                "        self.head = None\n",
                "    \n",
                "    def isEmpty(self):\n",
                "        return self.head == None\n",
                "    \n",
                "    def size(self):\n",
                "        current = self.head\n",
                "        count = 0\n",
                "        while current != None:\n",
                "            count += 1\n",
                "            current = current.getNext()\n",
                "        return count\n",
                "    \n",
                "    def remove(self,item):\n",
                "        current = self.head\n",
                "        previous = None\n",
                "        found = False\n",
                "\n",
                "        while not found:\n",
                "            if current.getData() == item:\n",
                "                found = True\n",
                "            else:\n",
                "                previous = current\n",
                "                current = current.getNext()\n",
                "        \n",
                "        if previous == None:\n",
                "            self.head = current.getNext()\n",
                "        else:\n",
                "            previous.setNext(current.getNext())\n",
                "    \n",
                "    def display(self):\n",
                "        elements = []\n",
                "        current = self.head\n",
                "        while current:\n",
                "            elements.append(str(current.getData()))\n",
                "            current = current.getNext()\n",
                "        return (\" -> \".join(elements))# This is not print, the following will use print; otherwise two prints in a row will end up with multiple None out\n",
                "\n",
                "# Changes are here\n",
                "    def search(self,item):\n",
                "        current = self.head\n",
                "        found = False\n",
                "        stop = False\n",
                "        while current != None and not found and not stop:#非空再判断下一步，不用getData()\n",
                "            if current.getData() == item:\n",
                "                found = True\n",
                "            else:\n",
                "                if current.getData() > item:\n",
                "                    stop = True# has changes over unordered tables!\n",
                "                else:\n",
                "                    current = current.getNext()\n",
                "        return found\n",
                "    \n",
                "    def add(self,item):\n",
                "        current = self.head\n",
                "        previous = None\n",
                "        stop = False\n",
                "        # Find the location\n",
                "        while current != None and not stop:#这里就俩\n",
                "            if current.getData() > item:\n",
                "                stop = True\n",
                "            else:\n",
                "                previous = current\n",
                "                current = current.getNext()\n",
                "\n",
                "        temp = Node(item)\n",
                "        '''\n",
                "        temp.setNext(current)\n",
                "        if previous == None:\n",
                "            self.head = temp\n",
                "        else:\n",
                "            previous.setNext(temp)\n",
                "'''\n",
                "\n",
                "        # New item at the beginning\n",
                "        \n",
                "        if previous == None:\n",
                "            temp.setNext(self.head)# or use self.head; here current is the very beginning of the\n",
                "            self.head = temp\n",
                "        else:\n",
                "            temp.setNext(current)\n",
                "            previous.setNext(temp)\n",
                "        "
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 34,
            "metadata": {},
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "True\n",
                        "False\n",
                        "6\n"
                    ]
                }
            ],
            "source": [
                "# Test cases\n",
                "\n",
                "ol = OrderedList()\n",
                "    # Test the isEmpty method\n",
                "\n",
                "print(ol.isEmpty())# \"isEmpty method test failed: list should initially be empty\"\n",
                "\n",
                " \n",
                "\n",
                "    # Test the add method\n",
                "\n",
                "ol.add(31)\n",
                "\n",
                "ol.add(77)\n",
                "\n",
                "ol.add(17)\n",
                "\n",
                "ol.add(93)\n",
                "\n",
                "ol.add(6)\n",
                "\n",
                "ol.add(54)\n",
                "\n",
                "print(ol.isEmpty()) #== False, \"isEmpty method test failed: list should not be empty after adding element\"\n",
                "    # Test the size method\n",
                "\n",
                "print(ol.size())# == 6), \"The size method test failed: the number of list elements should be 6\"\n",
                "\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 35,
            "metadata": {},
            "outputs": [
                {
                    "name": "stdout",
                    "output_type": "stream",
                    "text": [
                        "6 -> 17 -> 31 -> 54 -> 77 -> 93\n"
                    ]
                }
            ],
            "source": [
                "print(ol.display())"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 36,
            "metadata": {},
            "outputs": [
                {
                    "data": {
                        "text/plain": [
                            "'6 -> 17 -> 31 -> 54 -> 77 -> 93'"
                        ]
                    },
                    "execution_count": 36,
                    "metadata": {},
                    "output_type": "execute_result"
                }
            ],
            "source": [
                "ol.display()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "    # Test the search method\n",
                "\n",
                "print(ol.search(93))# == True)#, \"Search method test failed: should find element 93\"\n",
                "\n",
                "print(ol.search(99))# == False)#, \"Search method test failed: element 99 should not be found\"\n",
                "\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Test the remove method\n",
                "\n",
                "ol.remove(17)\n",
                "\n",
                "print(ol.size())# == 5)#, \"The remove method test failed: the number of list elements after removal should be 5\"\n",
                "\n",
                "print(ol.search(17))# == False)#, \"remove method test failed: element should not be found after removal\""
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Synthesize and analyze unordered and ordered tables, there:\n",
                "\n",
                "$\\implies$ For the analysis of the complexity of the chain table, the main thing is to see if the corresponding method involves **traversal** of the chain table"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "There are ordered tables there:\n",
                "|Operation |Time Complexity | Description |\n",
                "|:---:|:---:|:---:|             \n",
                "|Find Elements| O(n) | Similarly, in the worst case it is necessary to traverse the entire linked table, since linked lists are linear structures |\n",
                "|insert element| O(n) |need to traverse the chain table to find the right place to insert the new element to keep the chain table organized|\n",
                "|delete element| O(n) |Similar to unordered linked lists, you need to traverse the linked list to find the element to be deleted and then update the pointer|\n",
                "|Get the length of the linked table| O(n)| Same as unordered linked table, need to traverse the entire linked table unless a separate length variable is maintained, at which point the time complexity is O(1)|"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Unordered tables are available:\n",
                "\n",
                "|Operation |Time Complexity |Description |\n",
                "|:---:|:---:|:---:|                                                        \n",
                "|Find Element |O(n) |In the worst case, the entire chain table needs to be traversed to find the target element, where n is the length of the chain table|\n",
                "|Insert element into head |O(1) |Just create a new node and point it to the current head node, then update the head node to the new node|\n",
                "|delete element |O(n) |need to traverse the chain table to find the element to be deleted, then update the pointer to its previous node|\n",
                "|Get the length of the linked table |O(n) | requires traversing the entire linked table to count the number of elements, unless a separate length variable is maintained, in which case the time complexity is O(1)|."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "* :: The time complexity of a list implemented as a linked list is different from that of the python built-in list datatype for some of the same methods.\n",
                "* :: A linked table does not require contiguous storage space, but there is an additional cost to record the next node\n",
                "* :: Because python's native list is based on a sequential storage implementation and is optimized\n",
                "\n",
                "or rather\n",
                "Native lists are built-in datatypes, now in the Python interpreter under the hood (usually implemented in C) rather than in Python code."
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "Here is the homework section\n",
                "\n",
                "***************************************************"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# homework 1\n",
                "def func(S):\n",
                "    output = S\n",
                "    simqueue = S\n",
                "\n",
                "    for i in range(len(S)):\n",
                "        simqueue = simqueue[1:] + simqueue[0]\n",
                "        if  simqueue < output:\n",
                "            output = simqueue\n",
                "    return output\n",
                "    \n",
                "S = eval(input())#\"cba\"\n",
                "print(func(S))"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "#homework2,me done\n",
                "def func(mylist):\n",
                "    dict = {}\n",
                "    for key in mylist:\n",
                "        dict[key] = dict.get(key, 0) + 1\n",
                "    lis = sorted(dict.keys())\n",
                "\n",
                "    output = [dict[lis[0]]]\n",
                "    for i in range(1,len(lis)):\n",
                "        c = i - 1\n",
                "        count = dict[lis[i]]\n",
                "        while c >= 0 and lis[c] >= lis[i] - 10000:\n",
                "            count += dict[lis[c]]\n",
                "            c -= 1\n",
                "        output.append(count)\n",
                "    return output\n",
                "    \n",
                "mylist = eval(input())\n",
                "print(func(mylist))\n",
                "# Special values can't be handled, and there's out-of-computer time"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# homework2\n",
                "def func(mylist):\n",
                "    output = []\n",
                "    new_list = [] # Emulate a queue with a list\n",
                "    for i in range(len(mylist)):\n",
                "        new_list.append(mylist[i])\n",
                "        while new_list[-1] - new_list[0] > 10000:#看前面\n",
                "            new_list.pop(0)\n",
                "        count = 0\n",
                "        for j in range(i+1, len(mylist)):#看后面\n",
                "            if mylist[j] == mylist[i]:\n",
                "                count += 1\n",
                "            else:\n",
                "                break\n",
                "        output.append(len(new_list)+count)\n",
                "    return output\n",
                "\n",
                "\n",
                "mylist = eval(input())\n",
                "print(func(mylist))\n"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# HOMEWORK3\n",
                "# https://blog.csdn.net/suxiaorui/article/details/102102096\n",
                "def RadixSort(mylist):\n",
                "    i = 0 # initially sorted by digits\n",
                "    n = 1 # the smallest bit is set to 1 (contains 0)\n",
                "    max_num = max(mylist) #Get the maximum number in a sorted array\n",
                "    while max_num >= 10**n: #Get how many digits the max number is\n",
                "        n += 1\n",
                "    while i < n:\n",
                "        bucket = {} #Build the bucket from a dictionary.\n",
                "        for x in range(10):\n",
                "            bucket.setdefault(x, []) #Empty each bucket\n",
                "        for x in mylist: #sort each bit\n",
                "            radix =int((x / (10**i)) % 10) # get the base of each bit\n",
                "            bucket[radix].append(x) #add the corresponding array element to the bucket of the corresponding bit base\n",
                "        j = 0\n",
                "        for k in range(10):\n",
                "            if len(bucket[k]) ! = 0: # if bucket is not empty\n",
                "                for y in bucket[k]: # put each element in the bucket\n",
                "                    mylist[j] = y #put back into the array\n",
                "                    j += 1\n",
                "        i += 1\n",
                " \n",
                "if __name__ == '__main__':\n",
                "    mylist = eval(input())\n",
                "    RadixSort(mylist)\n",
                "    print(mylist)\n"
            ]
        }
    ],
    "metadata": {
        "kernelspec": {
            "display_name": "base",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.12.7"
        },
        "orig_nbformat": 2
    },
    "nbformat": 4,
    "nbformat_minor": 2
}